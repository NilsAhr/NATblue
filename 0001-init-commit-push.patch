From 33d5b62f57d2ab278932537d1176e0ca3f6860ad Mon Sep 17 00:00:00 2001
From: Nils Ahrenhold <nils.ahrenhold@dlr.de>
Date: Thu, 13 Feb 2025 15:52:41 +0100
Subject: [PATCH 1/5] init commit & push

---
 bluesky/plugins/birdtraffic.py                |  1026 +
 bluesky/plugins/cdbirds_windows.py            |   687 +
 bluesky/plugins/glbirds.py                    |   175 +
 bluesky/plugins/logger.py                     |   190 +-
 bluesky/plugins/randomize_birdies.py          |   176 +
 bluesky/plugins/windecmwf.py                  |     4 +-
 bluesky/plugins/windecmwfUP.py                |   270 +
 bluesky/plugins/windecmwfUP12.py              |   270 +
 bluesky/plugins/windgfsUP.py                  |   238 +
 bluesky/resources/navdata/airports.dat        |     6 +-
 bluesky/resources/navdata/nav.dat             |     3 +-
 bluesky/traffic/asas/mvp.py                   |     2 +-
 data/NetCDF/p_levels_20190315.nc              |   Bin 0 -> 3397682811 bytes
 data/NetCDF/p_levels_20190719.nc              |   Bin 0 -> 56733789 bytes
 data/NetCDF/p_levels_20190720.nc              |   Bin 0 -> 55567361 bytes
 data/NetCDF/p_levels_20190721.nc              |   Bin 0 -> 1784714271 bytes
 data/NetCDF/p_levels_20190724.nc              |   Bin 0 -> 47679089 bytes
 data/grib/gfsanl_3_20190315_0000_000.grb2     |   Bin 0 -> 18293622 bytes
 data/grib/gfsanl_3_20190315_0300_000.grb2     |   Bin 0 -> 20140029 bytes
 data/grib/gfsanl_3_20190315_0600_000.grb2     |   Bin 0 -> 18393573 bytes
 data/grib/gfsanl_3_20190315_0900_000.grb2     |   Bin 0 -> 20307005 bytes
 data/grib/gfsanl_3_20190315_1200_000.grb2     |   Bin 0 -> 18474242 bytes
 data/grib/gfsanl_3_20190315_1500_000.grb2     |   Bin 0 -> 20497381 bytes
 data/grib/gfsanl_3_20190315_1800_000.grb2     |   Bin 0 -> 18666066 bytes
 data/grib/gfsanl_3_20190315_2100_00.grb2      |   Bin 0 -> 20372539 bytes
 data/grib/gfsanl_3_20190719_0000_000.grb2     |   Bin 0 -> 26303462 bytes
 data/grib/gfsanl_3_20190719_0600_000.grb2     |   Bin 0 -> 26216420 bytes
 data/grib/gfsanl_3_20190719_1200_000.grb2     |   Bin 0 -> 26120913 bytes
 data/grib/gfsanl_3_20190720_0000_000.grb2     |   Bin 0 -> 26081944 bytes
 data/grib/gfsanl_3_20190720_0600_000.grb2     |   Bin 0 -> 26125341 bytes
 data/grib/gfsanl_3_20190720_1200_000.grb2     |   Bin 0 -> 26088619 bytes
 data/grib/gfsanl_3_20190720_1800_000.grb2     |   Bin 0 -> 26111590 bytes
 data/grib/gfsanl_3_20190721_0000_000.grb2     |   Bin 0 -> 25938613 bytes
 data/grib/gfsanl_3_20190721_0600_000.grb2     |   Bin 0 -> 25889627 bytes
 .../gfsanl_3_20190721_0600_000.grb2.5b7b6.idx |   Bin 0 -> 47294 bytes
 data/grib/gfsanl_3_20190721_1200_000.grb2     |   Bin 0 -> 25962637 bytes
 data/grib/gfsanl_3_20190721_1800_000.grb2     |   Bin 0 -> 25779194 bytes
 data/grib/gfsanl_3_20190722_0000_000.grb2     |   Bin 0 -> 25986963 bytes
 data/grib/gfsanl_3_20190722_0600_000.grb2     |   Bin 0 -> 26365237 bytes
 data/grib/gfsanl_3_20190722_1200_000.grb2     |   Bin 0 -> 26229041 bytes
 plugins_nils/rec.py                           |   244 -
 scenario/Nils/artd2025/baseline_static.scn    |  6264 +++
 scenario/Nils/artd2025/update12h.scn          |  6264 +++
 scenario/Nils/artd2025/update1h.scn           |  6264 +++
 scenario/Nils/artd2025/update2h.scn           |  6264 +++
 scenario/Nils/artd2025/update3h.scn           |  6264 +++
 scenario/Nils/artd2025/update4h.scn           |  6264 +++
 scenario/Nils/artd2025/update5h.scn           |  6264 +++
 scenario/Nils/artd2025/update6h.scn           |  6264 +++
 scenario/Nils/artd2025/update8h.scn           |  6264 +++
 scenario/Nils/batch_test.scn                  |    15 +
 scenario/Nils/batchfiles/artd2025.scn         |    21 +
 scenario/Nils/batchfiles/test.scn             |    18 +
 scenario/Nils/deletemulti.scn                 |    15 +
 scenario/Nils/deletetest.scn                  |    10 +
 scenario/Nils/flown.scn                       | 31356 ++++++++++++++++
 scenario/Nils/fuel_test.scn                   |    31 +
 scenario/Nils/fuel_test_nat.scn               |    15 +
 scenario/Nils/gc.scn                          | 31356 ++++++++++++++++
 scenario/Nils/jakob.scn                       | 10542 ++++++
 ...3_20200512_eggxczqx_330410_24600_263ac.scn | 15206 ++++++++
 ...c_20200512_eggxczqx_330410_24600_263ac.scn |  1072 +
 scenario/Nils/new_structure.scn               |   121 +
 scenario/Nils/pp.scn                          |  8138 ++++
 scenario/Nils/test.scn                        |   121 +
 scenario/Nils/test/nowind.scn                 | 11819 ++++++
 scenario/Nils/test/wind.scn                   | 11819 ++++++
 scenario/Nils/test/windup.scn                 | 11819 ++++++
 scenario/Nils/test_command.scn                |    15 +
 69 files changed, 192872 insertions(+), 304 deletions(-)
 create mode 100644 bluesky/plugins/birdtraffic.py
 create mode 100644 bluesky/plugins/cdbirds_windows.py
 create mode 100644 bluesky/plugins/glbirds.py
 create mode 100644 bluesky/plugins/randomize_birdies.py
 create mode 100644 bluesky/plugins/windecmwfUP.py
 create mode 100644 bluesky/plugins/windecmwfUP12.py
 create mode 100644 bluesky/plugins/windgfsUP.py
 create mode 100644 data/NetCDF/p_levels_20190315.nc
 create mode 100644 data/NetCDF/p_levels_20190719.nc
 create mode 100644 data/NetCDF/p_levels_20190720.nc
 create mode 100644 data/NetCDF/p_levels_20190721.nc
 create mode 100644 data/NetCDF/p_levels_20190724.nc
 create mode 100644 data/grib/gfsanl_3_20190315_0000_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_0300_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_0600_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_0900_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_1200_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_1500_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_1800_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190315_2100_00.grb2
 create mode 100644 data/grib/gfsanl_3_20190719_0000_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190719_0600_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190719_1200_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190720_0000_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190720_0600_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190720_1200_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190720_1800_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190721_0000_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190721_0600_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190721_0600_000.grb2.5b7b6.idx
 create mode 100644 data/grib/gfsanl_3_20190721_1200_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190721_1800_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190722_0000_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190722_0600_000.grb2
 create mode 100644 data/grib/gfsanl_3_20190722_1200_000.grb2
 delete mode 100644 plugins_nils/rec.py
 create mode 100644 scenario/Nils/artd2025/baseline_static.scn
 create mode 100644 scenario/Nils/artd2025/update12h.scn
 create mode 100644 scenario/Nils/artd2025/update1h.scn
 create mode 100644 scenario/Nils/artd2025/update2h.scn
 create mode 100644 scenario/Nils/artd2025/update3h.scn
 create mode 100644 scenario/Nils/artd2025/update4h.scn
 create mode 100644 scenario/Nils/artd2025/update5h.scn
 create mode 100644 scenario/Nils/artd2025/update6h.scn
 create mode 100644 scenario/Nils/artd2025/update8h.scn
 create mode 100644 scenario/Nils/batch_test.scn
 create mode 100644 scenario/Nils/batchfiles/artd2025.scn
 create mode 100644 scenario/Nils/batchfiles/test.scn
 create mode 100644 scenario/Nils/deletemulti.scn
 create mode 100644 scenario/Nils/deletetest.scn
 create mode 100644 scenario/Nils/flown.scn
 create mode 100644 scenario/Nils/fuel_test.scn
 create mode 100644 scenario/Nils/fuel_test_nat.scn
 create mode 100644 scenario/Nils/gc.scn
 create mode 100644 scenario/Nils/jakob.scn
 create mode 100644 scenario/Nils/m3_20200512_eggxczqx_330410_24600_263ac.scn
 create mode 100644 scenario/Nils/m3_gc_20200512_eggxczqx_330410_24600_263ac.scn
 create mode 100644 scenario/Nils/new_structure.scn
 create mode 100644 scenario/Nils/pp.scn
 create mode 100644 scenario/Nils/test.scn
 create mode 100644 scenario/Nils/test/nowind.scn
 create mode 100644 scenario/Nils/test/wind.scn
 create mode 100644 scenario/Nils/test/windup.scn
 create mode 100644 scenario/Nils/test_command.scn

diff --git a/bluesky/plugins/birdtraffic.py b/bluesky/plugins/birdtraffic.py
new file mode 100644
index 00000000..a80ca33c
--- /dev/null
+++ b/bluesky/plugins/birdtraffic.py
@@ -0,0 +1,1026 @@
+''' Bird traffic simulation plugin '''
+import numpy as np
+import os
+import pandas as pd
+
+
+import bluesky as bs
+from bluesky import core, stack
+from bluesky.tools.aero import ft, kts
+from bluesky.stack.cmdparser import append_commands
+#from bluesky.simulation import simt
+
+from plugins.randomize_birdies import randomize_birds
+from bluesky.core.walltime import Timer
+
+
+def init_plugin():
+    
+    global bird_traf
+    # initialize bird traffic
+    bird_traf = BirdTraffic()
+
+    
+    config = {
+        # The name of your plugin
+        'plugin_name'      : 'BIRDSIM',
+        'plugin_type'      : 'sim',
+        'update'           : update,
+        'reset'            : reset
+        }
+    print ("loaded birdtraf yay")
+    return config
+
+def update():
+    ''' not necessary anymore due to timer in init of BirdTraffic'''
+    # do modelling here. update bird state lat,lon,alt,trk,etc
+    
+    # send data to bird gui (this should be last step of your things)
+    #bird_traf.release_birds()
+    return
+    
+    
+
+def reset():
+  #  print ('BT - call reset')
+    # clear everything. TODO: smarter way to do this
+    #print('STACK - call bird reset')
+    bird_traf.reset()
+    
+    # release birds with no info to clear screen TODO: smarter way to do this
+    #bird_traf.release_birds()
+
+@stack.command(name='CREBIRD')
+def CREBIRD(birdid, bird_object: str="individual", bird_size: int = 4, no_inds: int = 1, birdlat: float=52., birdlon: float=4., birdtrk: float=None, birdalt: float=0,  
+        birdspd: float = 0):
+    '''for individual birdies'''
+    
+    ''' CREBIRD birdid,fl_of_ind, size, number,lat,lon,hdg,alt,spd '''
+    # correct some argument units
+    if bird_object == 'individual':
+        flock_flag = False
+    else: flock_flag = True
+    
+    
+    birdspd *= kts
+    birdalt *= ft
+
+    # create the bird
+    bird_traf.create_individual(birdid, flock_flag, bird_size, no_inds, birdlat, birdlon, birdtrk, birdalt, birdspd)
+
+
+
+@stack.command(name = 'DELBIRD')
+def DELBIRD(birdid):
+    # bird left the area, landed or was eaten by an aircraft
+    
+    # remove_bird needs an array index - convert
+    index_to_remove = bird_traf.id2idx(birdid)
+    #print ('remove from stack')
+    bird_traf.remove_bird(index_to_remove)
+    
+@stack.command(name = 'BIRDS')
+def BIRDS(filename):
+    '''when we want to load a scenario'''
+    # bird left the area, landed or was eaten by an aircraft
+    bird_traf.crescenario(filename)    
+
+
+######################################################################################################
+######################################################################################################
+######################################################################################################
+######################################################################################################      
+
+
+# CLASS BIRD TRAFFIC
+
+
+######################################################################################################
+######################################################################################################
+######################################################################################################
+######################################################################################################
+
+
+class BirdTraffic():
+   
+    def __init__(self):
+
+        
+        # to find bird files, we need to know the current directory
+        self.dir = os.path.dirname(__file__)
+        
+        # go back to the roots
+      #  print('BT - call from init')
+        self.reset()
+        self.scenario_loaded = False
+        self.id = []
+        
+        
+        # some global parameters
+        global earth_radius
+        earth_radius = 6371000.0 # Earth radius in m  
+        
+        global individual_radius
+        global flock_radius
+        
+        individual_radius = 0.5
+        flock_radius = 5.
+        
+        global lat_south
+        global lat_north
+        global lon_west
+        global lon_east
+        
+
+        lat_south = 51.2855167
+        lat_north = 51.552975
+
+        lon_west = 5.1347806
+        lon_east = 5.50
+        
+        
+         
+                 # see screenio.py
+        # Update rate of aircraft update messages [Hz]
+        ''' bird update is called from here at predefined rate'''
+        birdupdate_rate = 1
+
+        # create a timer to send bird data
+        self.fast_timer = Timer()
+        self.fast_timer.timeout.connect(self.release_birds)
+        self.fast_timer.start(int(1000 / birdupdate_rate))
+        
+        bs.traf.birdid = self.id
+
+
+
+######################################################################################################
+######################################################################################################      
+
+
+# CREATE BIRDS FROM SCENARIO FILE
+
+
+######################################################################################################
+######################################################################################################
+
+
+      
+    def crescenario(self,filename):
+        print ("whooooooooooooooooooooooop ", filename)
+        
+        self.scenario_loaded = True
+        
+    
+        #print "in readin", datetime.datetime.now() - self.starttime, datetime.datetime.now()
+    
+        # required for Monte-Carlo-Sims: the full name of the file (e.g. EGKK_2016_06_03-1)
+        # is needed for the logging. But as we have the same file as input for all
+        # of the scenarios, only EGKK_2016_06_03 should be used for the path
+        # where to read the file from
+        self.filename2save = filename # used for recording
+    
+        
+    
+        
+        # we do not always do MC simulations, so here is the back door
+        # for the aircraft-MC-simulations we need to make sure not to run birdie MC sims
+        # format of these files is EGKK_1-100-100-high/medium/low
+        if (len(self.filename2save) > 15) and (self.filename2save[-1].isdigit()):
+            print ("MONTE CARLO SIMULATION!", filename, filename[0:15])
+            filename2use = "bird_movements/" + filename[0:15] + ".csv"
+            filename_path = os.path.join(self.dir, filename2use)
+            print (filename_path)
+            
+            # in case of MC simulations, we want randomized speed, heading and position
+    
+            # if the filename works: pass on to randomizer
+            if os.path.isfile(filename_path):
+                
+                
+                # seed depends on bird movement plan number
+                # filename2use[15] is the underline. Hence the number starts at position filename2use[16]
+                seed = int(filename[16:])
+                print ("bird movement plan exists for that day, seed is ", seed)
+                data = randomize_birds(seed, filename_path)
+    
+                self.assign_values(data)
+                
+                
+            else:
+                print ("no such MC birdie file ", filename )     
+            
+            
+            
+            
+        else:
+
+            filename2use = "bird_movements/" + filename + ".csv"
+            filename = os.path.join(self.dir, filename2use)
+    
+            print ("we have a birdie file, we read from", filename)
+        
+            # if not: tell the user
+            #try:
+                
+                    # cat means bird size
+        
+                    # because of the MC simulations, more  columns are required. However, we only need the limited set to continue
+            data = pd.read_csv(filename, sep = "\,", \
+                                 names = ['id', 'date', 'lon','lat', 'alt', 'cat', 'no_individuals', 'flock_flag',\
+                                 'id1', 'hdg', 'spd', 'lat_s1', 'lat_n1', 'lon_w1', 'lon_e1','lat_s2', 'lat_n2', 'lon_w2', 'lon_e2'], index_col = False, engine = 'python')
+            
+                
+ 
+            '''HAS TO GO AWAY AGAIN'''
+            #data = pd.read_csv(filename, sep = "\,", \
+             #    names = ['id', 'date', 'lon','lat', 'alt', 'cat',  'flock_flag',\
+              #   'id1', 'hdg', 'spd', 'lat_s1', 'lat_n1', 'lon_w1', 'lon_e1','lat_s2', 'lat_n2', 'lon_w2', 'lon_e2'], index_col = False, engine = 'python')
+            #data['no_individuals'] = 1
+            
+            '''HAS TO GO AWAY AGAIN'''
+
+            data = data.drop(['lat_s1', 'lat_n1', 'lon_w1', 'lon_e1','lat_s2', 'lat_n2', 'lon_w2', 'lon_e2'], axis=1)
+            
+            # for the "next_ts", lat, lon, alt, we need to shift the respective cells
+            # BUT FIRST SORT CORRECTLY!
+            data = data.sort_values(['id','date'], ascending=[True, True])
+
+            data['timeshift'] = data['date'].shift(-1)
+            data['latshift'] = data['lat'].shift(-1)
+            data['lonshift'] = data['lon'].shift(-1)
+
+            
+            
+            '''to prevent birdies from being deleted one timestep too early respective start flying in a weird direction,
+            we give them a theoretical final position after which they are deleted '''
+            #print "init"
+            #print data
+
+            # the NaNs are the fly-outs - give them an extra 10 minutes
+            data['timeshift'].fillna(data['date'] + 600., inplace = True)
+
+            
+
+
+
+            #print 
+            #print "after timeshift filled"
+            #print data
+
+            # we need delta time, delta s
+            data['delta_t'] = data['timeshift'] - data['date']
+            
+            
+            data['delta_s'] = data['delta_t'] * data['spd']
+
+            #print 
+            #print "after delta s and delta t"
+            #print data
+            
+            # and now calculate the lat and lon out
+           # print ('we send to leo')
+            data['lat_leo'], data['lon_leo'] = self.calculate_leo_position(data['delta_t'], data['delta_s'], data['lat'], data['lon'], data['hdg'])
+            #print (data)
+            #print 
+            #print "after latlon_Leo"
+            #print data
+             
+            # and now replace all nans or 0s of the df in the latshift and lonshift 
+            data.loc[data['latshift'].isnull(),'latshift'] = data['lat_leo']
+            data.loc[data['lonshift'].isnull(),'lonshift'] = data['lon_leo']
+            
+            data.loc[data['latshift']== 0,'latshift'] = data['lat_leo']
+            data.loc[data['lonshift'] == 0,'lonshift'] = data['lon_leo']            
+            
+            #print 
+            #print "after all"
+            #print data
+            data = data.sort_values(by='date')
+            
+            #why not directly convert?
+            #--> INPUT IS IN DEGREES AND DUE TO NEW UPDATING WE DO NOT NEED
+                # RADIANS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!               
+
+
+                
+                
+            self.assign_values(data)
+                    
+           # except:
+            #    print ("no such individual birdie file")
+            #    return
+    
+        
+        return
+
+
+        
+
+######################################################################################################
+######################################################################################################      
+
+
+# UPDATE SCENARIO VALUES
+
+
+######################################################################################################
+######################################################################################################    
+
+    def update_scen(self):
+
+        # only process when there is at least one bird left
+
+        
+        if len(self.input_time) <1 or bs.sim.simt > self.input_time[-1]:
+            '''do we really want to reset here? or just return?'''
+            self.reset()
+            return
+        
+        # work with all values corresponding to timestamps already over
+        '''
+        This is a little faster (and looks nicer)
+
+        np.argmax(aa>5)
+
+        Since argmax will stop at the first True ("In case of multiple occurrences of the 
+        maximum values, the indices corresponding to the first occurrence are returned.") 
+        and doesn't save another list.
+        --> use  index in sense of input_time = self.input_time[0:index]
+        '''    
+            
+            
+        #idx_time_passed = np.where(self.input_time <= simtime)[0]  
+        idx_time_passed = np.argmax(self.input_time > bs.sim.simt)
+       # print "idx time passed", idx_time_passed      
+        
+            
+
+        
+
+        # bird info to the check-function
+        # check bird is performed for all the birds that we got in the lists
+        #print "we check", input_id1
+        if idx_time_passed > 0:
+            input_time            = self.input_time[ : idx_time_passed]
+            input_id1             = self.input_id1[ : idx_time_passed]
+            input_id2             = self.input_id2[ : idx_time_passed]
+            input_bird_size       = self.input_bird_size[ : idx_time_passed]
+            input_no_inds         = self.input_no_inds[ : idx_time_passed]
+            input_flock_flag      = self.input_flock_flag[ : idx_time_passed]
+            input_alt             = self.input_alt[ : idx_time_passed]      
+            input_lat             = self.input_lat[ : idx_time_passed]
+            input_lon             = self.input_lon[ : idx_time_passed]
+            input_spd             = self.input_spd[ : idx_time_passed]
+            input_hdg             = self.input_hdg[ : idx_time_passed]
+            
+            input_time_next       = self.input_time_next[ : idx_time_passed]
+            input_lat_next        = self.input_lat_next[ : idx_time_passed]
+            input_lon_next        = self.input_lon_next[ : idx_time_passed]
+                
+            self.check_bird(input_id1, input_bird_size, input_no_inds, input_flock_flag, input_alt)
+            #print "id after check", self.id
+            # there are probably birds in this set which reached their last timestep.
+            # they have to be removed
+            # trigger: id1 != id2
+            # input_id and self.id have different order - we need the positions
+            #  of self.id!
+            id_to_remove = input_id1[np.where(input_id1 != input_id2)[0]]
+            
+            if len(id_to_remove) > 0:
+                to_remove = []
+
+                for identity in id_to_remove:
+                    
+                    
+                    if identity in self.id:
+                        
+                        to_remove = to_remove + list(np.where(self.id == identity)[0])
+
+            # and remove the bird from the simulation
+            # but only if there is anything to remove
+               # print ("removing from next id")
+                self.remove_bird(to_remove) 
+                #print "id after remove", self.id
+
+                # input_id1 has to be adjusted as well, otherwise we run into 
+                # trouble with the curr_idx-comparison
+                # input_id1 = np.delete(input_id1, index_to_remove)
+
+
+        # position update
+        # explanation np.ndenumerate: index is the iterator through the array
+        # while id1 is the actual value. 
+        # e.g. ([4,3,7]): index = 0,1,2, id1 = 4,3,7
+            
+            for index, id1 in np.ndenumerate(input_id1):
+                index_to_replace = np.where(self.id == id1)[0]        
+
+                self.last_ts[index_to_replace]  = input_time[index]
+                self.last_lat[index_to_replace] = input_lat[index]
+                self.last_lon[index_to_replace] = input_lon[index]
+                
+                self.next_ts[index_to_replace]  = input_time_next[index]
+                self.next_lat[index_to_replace] = input_lat_next[index]
+                self.next_lon[index_to_replace] = input_lon_next[index]                
+                
+                
+                self.tas[index_to_replace]      = input_spd[index]
+                self.trk[index_to_replace]      = input_hdg[index]
+               # print ('in update, track is', self.trk, 'input hdg', input_hdg)
+                        
+               # perform some data logging here for the init birdies
+                    
+                # prepare the data
+                #print "birdies are", self.id
+                #print "we look at  birdie", input_id1[index], self.id[index_to_replace], type(self.id[index_to_replace]), self.last_lon[index_to_replace], input_lon[index]
+                '''bird_data = str(self.id[index_to_replace])  + ' \t ' + str(self.last_lat[index_to_replace]) + \
+                    ' \t ' + str(self.last_lon[index_to_replace]) + ' \t ' + str(self.alt[index_to_replace]) + \
+                    ' \t ' + str(self.collision_radius[index_to_replace]) + ' \t ' + str(self.bird_size[index_to_replace]) 
+
+                # required: filename,time, bird data: 'date \t time \t id_bird  \t lat \t lon \t alt \t coll_rad \t size \n'
+                self.log.write_birds(self.filename2save, simtime, bird_data)
+                    
+            #save bird trajectories every self.logdt seconds
+                if abs(simtime - self.logt0) >= self.logdt:
+        
+                    self.logt0 = simtime                    
+                    
+                    # storing only in intervals
+                    self.log.save_birds(self.filename2save)'''
+                    
+            
+
+
+
+            self.remove_input(idx_time_passed)
+        
+        
+        self.update_position()
+        
+        
+        return
+
+
+
+############################
+#CHECK BIRDS
+############################
+
+    # check whether the current bird is known already. If not, create    
+    def check_bird(self, input_id1, input_bird_size, input_no_inds, input_flock_flag, input_alt):
+
+        # test 1: not in removed_id: if an avian radar bird was eaten by
+        # an aircraft, it still might have track data. But as it has been eaten,
+        # it can't fly anymore
+
+        # WARNING: THis bird_idx_to add does refer to the idx in the list "input_id1", not the position
+        # in the input list containing all birdies
+        bird_idx_to_add = np.where(np.in1d(input_id1, self.removed_id, invert = True) & (np.in1d(input_id1, self.id, invert = True)))[0]
+
+
+#print test[np.where(np.in1d(test, already_in, invert = True) & (np.in1d(test, killed, invert = True)))[0]]
+
+            
+            # np.where idx is not in removed or id
+            # append the values with these idxs
+            
+       # print "inputs", input_id1, input_bird_size, input_flock_flag, input_alt
+        #print "in removed", np.in1d(input_id1, self.removed_id, invert = True), "in id", (np.in1d(input_id1, self.id, invert = True)), "both", bird_idx_to_add, "id", self.id, "removed", self.removed_id, "input", input_id1      
+        
+        # collision radius of birds: f(span, size, number)
+        add_no_inds = input_no_inds[bird_idx_to_add]
+        add_bird_size = input_bird_size[bird_idx_to_add]
+
+
+        # spans are
+        # small: 0.34 m
+        # medium: 0.69 m
+        # large: 1.43 m
+     
+        # radius for protected zone around birds
+        add_radius = np.zeros(len(bird_idx_to_add))
+
+        # *0.5 because span is diameter and we need radius
+        add_radius[add_bird_size == 6] = (np.sqrt(add_no_inds[add_bird_size == 6])* 0.5 * 0.32) + 0.06
+        add_radius[add_bird_size == 5] = (np.sqrt(add_no_inds[add_bird_size == 5])* 0.5 * 0.68) + 0.16
+        add_radius[add_bird_size == 4] = (np.sqrt(add_no_inds[add_bird_size == 4])* 0.5 * 1.40) + 0.41
+        
+        add_radius[np.where((add_bird_size == 6)&(add_no_inds ==1))] = 0.5 * 0.32
+        add_radius[np.where((add_bird_size == 5)&(add_no_inds ==1))] = 0.5 * 0.68
+        add_radius[np.where((add_bird_size == 4)&(add_no_inds ==1))] = 0.5 * 1.40
+
+
+        
+        self.id         = np.append(self.id, input_id1[bird_idx_to_add])
+        self.bird_size  = np.append(self.bird_size, add_bird_size )
+        self.no_inds    = np.append(self.no_inds, add_no_inds )
+        self.flock_flag = np.append(self.flock_flag, input_flock_flag[bird_idx_to_add])
+        # and a placeholder for all the other items
+        self.last_ts  = np.append(self.last_ts, np.zeros([len(bird_idx_to_add)])) 
+        self.last_lat = np.append(self.last_lat, np.zeros([len(bird_idx_to_add)]))
+        self.last_lon = np.append(self.last_lon, np.zeros([len(bird_idx_to_add)]))
+        
+        self.next_ts  = np.append(self.next_ts, np.zeros([len(bird_idx_to_add)])) 
+        self.next_lat = np.append(self.next_lat, np.zeros([len(bird_idx_to_add)]))
+        self.next_lon = np.append(self.next_lon, np.zeros([len(bird_idx_to_add)]))        
+        
+        
+        
+        
+        self.lat      = np.append(self.lat, np.zeros([len(bird_idx_to_add)]))
+        self.lon      = np.append(self.lon, np.zeros([len(bird_idx_to_add)]))
+        self.tas      = np.append(self.tas, np.zeros([len(bird_idx_to_add)]))
+        self.trk      = np.append(self.trk, np.zeros([len(bird_idx_to_add)]))
+
+        self.alt      = np.append(self.alt, input_alt[bird_idx_to_add])
+        self.collision_radius = np.append(self.collision_radius, add_radius)
+        
+
+        return
+
+############
+# REMOVE INPUT
+############
+
+
+    def remove_input(self, no_to_remove):
+
+        # remove the info we already looked at
+    # these are the first x elements. So the array now starts at the position [element]+1
+
+        self.input_time             = self.input_time[no_to_remove :]
+        self.input_id1              = self.input_id1[no_to_remove :]
+        self.input_id2              = self.input_id2[no_to_remove :]
+        self.input_lat              = self.input_lat[no_to_remove :]
+        self.input_lon              = self.input_lon[no_to_remove :]
+        self.input_spd              = self.input_spd[no_to_remove :]
+        self.input_hdg              = self.input_hdg[no_to_remove :]   
+        self.input_alt              = self.input_alt[no_to_remove :]
+        self.input_flock_flag       = self.input_flock_flag[no_to_remove :]
+        self.input_bird_size        = self.input_bird_size[no_to_remove :]
+        self.input_no_inds          = self.input_no_inds[no_to_remove : ]
+
+
+        self.input_time_next        = self.input_time_next[no_to_remove :]
+        self.input_lat_next         = self.input_lat_next[no_to_remove :]
+        self.input_lon_next         = self.input_lon_next[no_to_remove :]
+
+        
+        return
+
+
+##############
+# UPDATE POSITION
+##############
+
+    def update_position(self):
+        
+        
+      
+        # timedelta between last and next
+        entire_delta_t = self.next_ts - self.last_ts
+        delta_time_now = bs.sim.simt - self.last_ts
+
+        self.lat = (self.next_lat - self.last_lat) * (delta_time_now/entire_delta_t) + self.last_lat
+        self.lon = (self.next_lon - self.last_lon) * (delta_time_now/entire_delta_t) + self.last_lon
+       # print ('last lat', self.last_lat, 'last lon', self.last_lon, 'current lat', self.lat, 'current lon', self.lon, 'next lat', self.next_lat, 'next lon', self.next_lon)
+        
+       # with open ("taraaaa.txt", "a") as tara:
+            
+        #    for i in xrange(len(self.id)):
+         #       print "writiiiiiing", self.id, self.lat, self.lon, self.last_ts, self.next_ts
+          #      tara.write(str(self.id[i]) + ' \t ' + str(simtime) + ' \t ' + str(self.lat[i]) + ' \t ' + str(self.lon[i]) + '\n')
+        '''delta_t = abs(simtime - self.last_ts)
+        delta_s = self.tas * delta_t
+        #print "lastts", self.last_ts[0:10],  "simtime", simtime
+        #print "DELTAAAAAAAAAAAAAAAAA", delta_t[0:10]
+        
+        
+        
+        self.calculate_position(delta_t, delta_s, simtime)'''
+        
+        # removal of birds that left the area: only once per minute
+        if abs(bs.sim.simt - self.deletet0) >= self.deletedt:
+            
+            # test if any birds already left the area
+            left_south = np.where(self.lat < lat_south)[0]
+            left_north = np.where(self.lat > lat_north)[0]
+            left_west  = np.where(self.lon < lon_west)[0]
+            left_east  = np.where(self.lon > lon_east)[0]
+            
+            all_left = list(np.unique(np.concatenate((left_south, left_north, left_west, left_east))))
+            if len(all_left)  > 0:
+              #  print ("removing all left")
+                self.remove_bird(all_left)
+            
+            # reset timer
+            self.deletet0 = bs.sim.simt
+            
+            
+        return
+
+
+
+######################################################################################################
+######################################################################################################      
+
+
+# CREATE INDIVIDUAL BIRDIES FOR TESTING PURPOSES
+
+
+######################################################################################################
+######################################################################################################        
+        
+        
+        
+        
+    
+    def create_individual(self, birdid, flock_flag, bird_size, no_inds, birdlat, birdlon, birdtrk, birdalt, birdspd):
+        '''Creating solo birdies for testing'''
+        
+        # add one bird object
+        n = 1
+
+        # increase number of birds
+        self.nbird += n
+
+        # get position of bird
+       # print ("bird lat lon input", birdlat, birdlon)
+        birdlat = np.array(n * [birdlat])
+        birdlon = np.array(n * [birdlon])
+
+        # Limit longitude to [-180.0, 180.0]
+        birdlon[birdlon > 180.0] -= 360.0
+        birdlon[birdlon < -180.0] += 360.0
+        
+       # print ('bird lat lon output', birdlat, birdlon)
+
+        # add to birdinfo to lists
+        self.id = np.append(self.id, birdid)
+        self.flock_flag = np.append(self.flock_flag, flock_flag)
+        self.bird_size = np.append(self.bird_size, bird_size)
+        self.no_inds = np.append(self.no_inds, no_inds)
+
+        # Positions
+        self.lat = np.append(self.lat, birdlat)
+        self.lon = np.append(self.lon, birdlon)
+        self.alt = np.append(self.alt, birdalt)
+
+        # Heading
+        self.trk = np.append(self.trk, birdtrk)
+
+        # Velocities
+        self.tas = np.append(self.tas, birdspd)
+        
+        # TODO: think about vs once we talk 3D birdies
+        #vs = 0
+        #self.vs = np.append(self.vs, vs)
+        
+        # radius of protected zone
+        if no_inds < 2:
+
+            if bird_size == 6:
+                self.collision_radius = np.append(self.collision_radius,  0.5 * 0.32)
+            elif bird_size == 5:
+                self.collision_radius = np.append(self.collision_radius,  0.5 * 0.68)
+            elif bird_size == 4:
+                self.collision_radius = np.append(self.collision_radius,  0.5 * 1.40)                
+            else:
+                print ("solo birdie size not captured", bird_size)
+                
+                
+        else:
+
+            
+            if bird_size == 6:
+                self.collision_radius = np.append(self.collision_radius,  np.sqrt(no_inds)* 0.5 * 0.32 + 0.06)
+            elif bird_size == 5:
+                self.collision_radius = np.append(self.collision_radius,  np.sqrt(no_inds)* 0.5 * 0.68 + 0.16)
+            elif bird_size == 4:
+                self.collision_radius = np.append(self.collision_radius,  np.sqrt(no_inds)* 0.5 * 1.40 + 0.41)                
+            else:
+                print ("gang birdie size not captured", bird_size)            
+            
+     
+        # and stuff for calculating
+        # --> will NOT work yet but since it is for testing only anyways...
+        # probably: last lat = input lat, next lat = 10 minute flight with selected heading
+        self.last_ts          = np.append(self.last_ts, -999)
+        self.last_lat         = np.append(self.last_lat, -999)
+        self.last_lon         = np.append(self.last_lon, -999)
+        
+        self.next_ts          = np.append(self.next_ts, -999)
+        self.next_lat         = np.append(self.next_lat, -999)
+        self.next_lon         = np.append(self.next_lon, -999)          
+                
+        
+        return
+
+    
+    def update_individual_position(self):
+        ''' here, the lat lon position will be updated
+        
+        use the latitude and longitude the bird has right now as well as the current speed and heading.
+        
+        check the calculate_leo() function on how I did this for scenario birdies. 
+        maybe you can even just directly use it - your task to find out :)
+            Even if you do, I recommend that you copy the "calculate leo" function, give it another name,
+            e.g "calculate_leo_ind_birds" or whatever you like and work with that function. 
+            Then you can make adjustments if needed. For example, you can directly access
+            self.lat, self.lon, self.trk and do not have to hand them over to the function.
+        
+        Be careful with radians and degrees and with units!!!
+        --> the simulator usually needs degrees and will show imperial units in the user interface
+        --> calculations need to be performed in radians and with metric values (see the converting in calculate_leo for example)
+        
+        
+        
+        
+        '''
+        #print ('updating individual position')
+        return
+    
+    
+ 
+    
+ 
+    
+    #@core.timed_function(name='example', dt=5)
+    #def update(self):
+     #       ''' Periodic update function for our example entity. '''
+    #        print ('updating, huiiiiiiiii')
+            #bird_traf.release_birds()
+    
+ 
+    
+ 
+    
+    
+    
+######################################################################################################
+######################################################################################################      
+
+
+# DELETE BIRDS FROM SIMULATION
+    # a) because they left the area
+    # b) because an aircraft had them for breakfast
+
+
+######################################################################################################
+######################################################################################################      
+    
+ 
+    def remove_bird(self, index_to_remove):
+
+        
+        # as soon as a bird leaves the simulation, its information has to be removed
+        # idx is the index, where the bird info is stored per list
+        
+        # also gets called when a bird gets hit by an aircraft        
+
+        
+        
+        
+        # list of removed birds
+        self.removed_id = np.append(self.removed_id, self.id[index_to_remove])
+        
+        
+        self.nbird = self.nbird - 1 # number of birds
+        
+        # basic info
+        self.id               = np.delete(self.id, index_to_remove)
+        self.flock_flag       = np.delete(self.flock_flag, index_to_remove)
+        self.bird_size        = np.delete(self.bird_size, index_to_remove)
+        self.no_inds          = np.delete(self.no_inds, index_to_remove)
+        self.collision_radius = np.delete(self.collision_radius, index_to_remove)
+
+        # Positions
+        self.lat              = np.delete(self.lat, index_to_remove)
+        self.lon              = np.delete(self.lon, index_to_remove)  
+        self.alt              = np.delete(self.alt, index_to_remove)       
+        self.trk              = np.delete(self.trk, index_to_remove)  
+        
+
+        # Velocities
+        self.tas     = np.delete(self.tas, index_to_remove)    # horizontal airspeed [m/s]
+       # self.vs     = np.delete(self.vs, index_to_remove)   # vertical speed [m/s]
+        
+        
+        self.last_ts          = np.delete(self.last_ts, index_to_remove)
+        self.last_lat         = np.delete(self.last_lat, index_to_remove)
+        self.last_lon         = np.delete(self.last_lon, index_to_remove)
+        
+        self.next_ts          = np.delete(self.next_ts, index_to_remove)
+        self.next_lat         = np.delete(self.next_lat, index_to_remove)
+        self.next_lon         = np.delete(self.next_lon, index_to_remove)        
+        
+        return
+
+
+
+    
+######################################################################################################
+######################################################################################################      
+
+
+# RESET ALL BIRD INFORMATION
+
+
+######################################################################################################
+######################################################################################################  
+    
+    
+    def reset(self):
+        # clear all TODO: copy traffarrays
+       # print ('BT - in reset')
+        self.nbird = 0 # number of birds
+        self.scenario_loaded = False
+        
+        # initialize bid array
+        self.id         = np.array([], dtype = int)      
+        self.flock_flag = np.array([], dtype = int)
+        self.bird_size  = np.array([], dtype = int)
+        self.no_inds    = np.array([], dtype = int)
+        self.collision_radius = np.array([])
+        
+
+        # Positions
+        self.lat     = np.array([], dtype=float)  # latitude [deg]
+        self.lon     = np.array([], dtype=float)  # longitude [deg]
+        self.alt     = np.array([], dtype=float)  # altitude [m]
+        self.trk     = np.array([], dtype=float)  # traffic track [deg]
+
+        # Velocities
+        self.tas     = np.array([], dtype=float)   # horizontal airspeed [m/s]
+        #self.vs     = np.array([], dtype=float)  # vertical speed [m/s]
+        
+        
+         # from old BlueSky
+                 # values from file
+        self.input_time = np.array([])
+        
+        # values for calculation 
+        self.last_ts    = np.array([])
+        self.last_lat   = np.array([])
+        self.last_lon   = np.array([])
+        
+        self.next_ts    = np.array([])
+        self.next_lat   = np.array([])
+        self.next_lon   = np.array([])        
+        
+        self.input_time_next = np.array([])
+        self.input_lat_next = np.array([])
+        self.input_lon_next = np.array([])
+        
+
+
+        
+        # birds which experienced a strike don't fly anymore
+        self.removed_id = np.array([])
+        
+        # set timer for deletions
+        self.deletedt = 60. # [s] interval to delete birds that left the area
+        self.deletet0 = -self.deletedt # init
+
+
+        # scheduling of datalog
+        self.logdt = 10.
+        self.logt0 = -self.logdt
+        
+        
+     #   print ("BT - END RESET", self.id)
+        
+        
+        return
+    
+######################################################################################################
+######################################################################################################      
+
+
+# HELPER FUNCTIONS
+
+
+######################################################################################################
+######################################################################################################   
+    
+
+
+
+######################################################################################################      
+# id2idx
+######################################################################################################
+    
+    def id2idx(self, birdid):
+        """Find index of bird id"""
+
+        return np.where(self.id == np.char.upper(np.array(birdid)))[0][0]
+
+
+
+
+######################################################################################################      
+# assigning input values for bird scenarios
+######################################################################################################
+    def assign_values(self, data):
+        self.input_id1 = np.array(pd.to_numeric(data["id"])).astype(int)
+        self.input_id2 = np.array(pd.to_numeric(data["id1"])).astype(int)
+        self.input_lat = np.array(pd.to_numeric(data["lat"]))
+        self.input_lon = np.array(pd.to_numeric(data["lon"]))
+        self.input_spd = np.array(pd.to_numeric(data["spd"]))
+        self.input_hdg = np.array(pd.to_numeric(data["hdg"]))
+        self.input_alt = np.array(pd.to_numeric(data["alt"]))
+        
+        self.input_bird_size  = np.array(pd.to_numeric(data["cat"])).astype(int)
+        self.input_flock_flag = np.array(data["flock_flag"])
+        self.input_no_inds    = np.array(data['no_individuals']).astype(int)
+        
+        self.input_time = np.array(pd.to_numeric(data['date']))   
+        
+        
+        self.input_time_next = np.array(pd.to_numeric(data['timeshift']))
+        self.input_lat_next = np.array(pd.to_numeric(data['latshift']))
+        self.input_lon_next = np.array(pd.to_numeric(data['lonshift']))
+        
+        
+
+        return
+
+######################################################################################################      
+# Leo's positions
+###################################################################################################### 
+
+
+    def calculate_leo_position(self, delta_t, delta_s, lat_in, lon_in, hdg):
+        '''to prevent birdies from being deleted one timestep too early respective start flying in a weird direction,
+        we give them a theoretical final position after which they are deleted '''
+        theta = np.radians(hdg)
+        last_lat = np.radians(lat_in)
+        last_lon = np.radians(lon_in)
+       # print ('in leo', lat_in, lon_in, hdg)
+        
+        d = delta_s/earth_radius
+
+
+        # calculate the next position with the haversine function
+        # check http://www.movable-type.co.uk/scripts/latlong.html for reference
+        
+        lat_pos = np.arcsin(np.sin(last_lat)*np.cos(d) + np.cos(last_lat)*np.sin(d)*np.cos(theta))
+        
+        lon_pos = last_lon + np.arctan2(np.sin(theta)*np.sin(d)*np.cos(last_lat),
+                      np.cos(d) - np.sin(last_lat)*np.sin(lat_pos))        
+                
+        lat_theo = np.degrees(lat_pos)
+        lon_theo = np.degrees(lon_pos)
+        #print lat_theo
+        #with open ("taraaaa.txt", "a") as tara:
+            
+
+        return lat_theo, lon_theo
+
+
+
+    
+    
+######################################################################################################      
+# sending birds from sim to gui
+######################################################################################################    
+    def release_birds(self):
+         
+         '''release them to the visual world '''
+        
+         ''' we need to differentiate between individuals and scenarios
+        - for now, either one or the other'''
+         
+         if self.scenario_loaded:
+            
+            self.update_scen()
+            
+         else:
+            '''by now, individual birdies do not move
+            here is the call to do updates of individual bird positions'''
+            self.update_individual_position()
+            
+        
+         data = dict()
+         # id is necessary for some gui stuff
+         data['id']         = self.id
+         #data['type']       = self.type
+         data['lat']        = self.lat
+         data['lon']        = self.lon
+         data['alt']        = self.alt
+         data['trk']        = self.trk
+         #data['tas']         = self.tas
+         #data['hs']         = self.hs
+       #  print ('bird track is', self.trk)
+         
+         
+ 
+         # send bird data
+         bs.net.send_stream(b'BIRDDATA', data)
+        # print ("BT - releasing", data['id'])
+        
+         return   
+
+
+
diff --git a/bluesky/plugins/cdbirds_windows.py b/bluesky/plugins/cdbirds_windows.py
new file mode 100644
index 00000000..8571ec38
--- /dev/null
+++ b/bluesky/plugins/cdbirds_windows.py
@@ -0,0 +1,687 @@
+# -*- coding: utf-8 -*-
+"""
+Created on Thu Nov 17 08:49:23 2016
+
+@author: metz_is
+"""
+
+
+
+import numpy as np
+
+
+''' TODO: DATA LOG'''
+#import CDatalog
+
+
+import os
+import pandas as pd
+
+
+import bluesky as bs
+from bluesky import core, stack
+from bluesky.core import Entity, trafficarrays
+from bluesky.tools.aero import ft, kts
+from bluesky.stack.cmdparser import append_commands
+#from bluesky.simulation import simt
+
+#from plugins.birds.randomize_birdies import randomize_birds
+from bluesky.core.walltime import Timer
+from bluesky.traffic import Traffic 
+from plugins.birdtraffic import BirdTraffic
+
+import os
+dir = os.path.dirname(__file__)
+
+
+def init_plugin():
+    
+    global bird_cdr
+    
+    bird_cdr = Conflict_Detection_Birds()
+
+    
+    config = {
+        # The name of your plugin
+        'plugin_name'      : 'BIRDCDR',
+        'plugin_type'      : 'sim',
+        'update'           : update,
+        }
+    print ("loaded birdtraf yay")
+    return config
+
+
+
+
+def access_plugin_module(plugin_name):
+    ''' access bluesky module by name - here birdtraf
+    --> can be done via core once the merge from the main was performed'''
+    
+    plugin_name = plugin_name.lower()
+    
+    plugin_module = dict(bs.core.varexplorer.varlist)[plugin_name][0]
+    
+    
+    return plugin_module
+
+
+
+
+
+
+def update():
+    # do modelling here. update bird state lat,lon,alt,trk,etc
+    
+    # send data to bird gui (this should be last step of your things)
+    #bird_traf.release_birds()
+    
+    ''' no manual update rate here but checking as often as feasible for
+    the simulation because approaches of birds and aircraft happen very quickly
+    due to high aircraft speeds. We wouldn't want to miss a collision'''
+    
+    # this is Isabel's one
+   # bird_cdr.conflict_detection()
+    
+    # this is Isha's one
+    bird_cdr.collision_avoidance()
+    bird_cdr.log_aircraft_trajectory()
+
+    # make sure that bs traffic elements are updated
+    bs.traf.ac_collision_radius = bird_cdr.ac_collision_radius
+    bs.traf.ac_collision_height = bird_cdr.ac_collision_height  
+    bs.traf.ac_collision_sweep  = bird_cdr.ac_collision_sweep     
+    
+    
+
+
+
+    
+    return
+
+@stack.command(name = 'LOGNAME')
+def LOGNAME(filename):
+    '''when we want to load a scenario'''
+
+    # bird left the area, landed or was eaten by an aircraft
+    bird_cdr.set_logname(filename) 
+    
+    return
+
+@stack.command(name = 'CRE_BIRDAC')
+def CRE_BIRDAC(acid, actype: str="B744", aclat: float=52., aclon: float=4., achdg: float=None, acalt: float=0,  
+        acspd: float = 0):
+    """CREM2 acid, type, [latlon], [hdg], [alt], [spd], prio"""
+    ## DEPRECATED!!!
+    # Creates an aircrft, but also assigns priority
+    # Convert stuff for bs.traf.cre
+
+    # correct some argument units
+    acspd *= kts
+    acalt *= ft
+        
+    # First create the aircraft
+
+    bs.traf.cre(acid, actype, aclat, aclon, achdg, acalt, acspd)
+
+       
+    # Then assign its collision envelope
+    idx = bs.traf.id.index(acid)
+
+    
+    coll_rad, coll_height, coll_sweep = bird_cdr.assign_envelope(actype)
+
+    
+  #  bs.traf.priority[idx] = prio
+
+    # you can just do this
+    bird_cdr.ac_collision_radius[idx] = coll_rad
+    bird_cdr.ac_collision_height[idx] = coll_height
+    bird_cdr.ac_collision_sweep[idx]  = coll_sweep
+    
+    # bs.traf.ac_collision_radius[idx] = 342.
+    # bs.traf.ac_collision_height[idx] = coll_height
+    # bird_cdr.traf.ac_collision_radius[idx] = 18.
+    # bird_cdr.traf.ac_collision_height[idx] = coll_height
+
+
+    # add path plan for specific aircraft
+    #bs.traf.path_plans[-1] = path_plan_dict[ACID]
+
+    return
+
+
+
+
+
+
+
+
+
+##############################################################################
+###
+###
+###
+##############################################################################
+
+
+
+
+class Conflict_Detection_Birds(Entity):
+    
+    def __init__(self):
+        
+        super().__init__()
+        ''' get our birdie info from birdtraffic'''
+        
+        birdtraf_module = access_plugin_module('BIRDSIM')
+        self.birds = birdtraf_module.bird_traf
+        self.traf = bs.traf
+        
+        with self.settrafarrays():
+            # initialization of extra traffic information, in this case
+            #  collision envelope. Add variables for other parts of the 
+            # safety envelope here
+            
+            self.ac_collision_radius = np.array([], dtype=int)
+            self.ac_collision_height = np.array([], dtype=int)
+            self.ac_collision_sweep = np.array([], dtype=int)
+
+            # print ('we initialized', self.traf.ac_collision_radius, self.ac_collision_radius)
+
+        # and make life with regard to traf a bit easier
+        bs.traf.ac_collision_radius = self.ac_collision_radius
+        bs.traf.ac_collision_height = self.ac_collision_height  
+        bs.traf.ac_collision_sweep = self.ac_collision_sweep 
+        
+
+
+        self.counter_strikes = 0
+        self.counter = 0
+        
+        global earth_radius
+        earth_radius = 6371000.0 # Earth radius in m          
+        self.coslat = np.cos(np.radians(51.4192475))
+        # Create datalog instance
+
+        self.log = Datalog()
+        self.reset()
+        
+
+        
+        
+        
+        # for logging we need a filename. If we use the IC, the name is given
+        # this is a placeholder to avoid errors in case no logname is provided in the 
+        # scenario
+        self.filename2save = 'ZZZZ_bird_logging'
+        
+        
+        ''' to perform CD, we need to know whether the bird enters the 
+        safety envelope. For that purpose, we need to define the expansion of the 
+        safety envelope. Here, the required parameters are initialized. In "add_envelope", 
+        they will be assigned to newly created aircraft'''
+        
+
+
+
+        return
+    
+    def create(self, n=1):
+        
+        ''' this is to ensure that we have arrays for collision envelopes which
+        we can fill with values later on '''
+        super().create(n)
+
+
+        self.ac_collision_radius[-n:] = 20. # unit is m
+        self.ac_collision_height[-n:] = 1.42 # unit is m
+        self.ac_collision_sweep[-n:]  = 24. # degrees
+
+        
+        
+
+    def assign_envelope(self, ac_type):
+        
+        ### now we have hard-coded radii and heights. Add a function here
+        ### to assign the values depending on the aircraft type
+        # different numbers to init for checking only
+        coll_rad = 42.
+        coll_height = 1.49
+        
+        # sweep is relevant for fixed-wing aircraft to ensure that
+        # only collisions to the front of the aircraft are counted
+        # if you want the full circle, use 90 for your aircraft types
+        coll_sweep = 26.
+        
+        return coll_rad, coll_height, coll_sweep
+
+        
+
+
+    
+    def set_logname(self, filename):
+        # assigning the actual logname for the logfile recording collision parameters.
+        
+        self.filename2save = filename    
+        
+
+        return
+    
+    
+
+    def reset(self):
+
+        
+        self.counter = self.counter + 1
+
+        self.filename_set = False
+        
+        
+        return        
+     
+        
+    def log_aircraft_trajectory(self):
+            # copy logging info stuff here
+        return
+        
+    def collision_avoidance(self)   :
+        
+        if (len(self.birds.id) <1 ) or (len(self.traf.id) <1):
+            return        
+        
+        
+       # print ('we are in Ishas function, yay ')
+       #
+        '''replace with self.birds.collision_radius and self.ac_collision_radius to ensure that you 
+       have as many radii as you have traffic participants! This now is just a quick fix for a 1-1 comparison!'''
+       
+       
+       # will be replaced with warning radius
+        crit_dist_ac_in = np.array([20.])
+        crit_dist_bird_in =  np.array([1.])
+        
+        
+        # !!! homework for Isha: implement ac_warn_radius and ac_caution_radius as it is done for collision radius. Check for EVERY occurrence
+        
+        '''replace with these lines and change the values for collision radii where they are initialized in birdtraf.'''
+        #crit_dist_ac = self.birds.collision_radius.reshape(len(self.birds.collision_radius), 1)
+        #crit_dist_b = self.ac_collision_radius.reshape(1,len(self.ac_collision_radius))        
+
+        crit_dist_ac = crit_dist_ac_in.reshape(len(crit_dist_ac_in), 1)
+        crit_dist_b = crit_dist_bird_in.reshape(1,len(crit_dist_bird_in))           
+        
+        
+        
+
+        lat_birds, lon_birds, alt_birds, lat_aircraft, lon_aircraft, alt_aircraft = self.reshape()       
+       # print ("lat bird", lat_birds, "lat aircraft", lat_aircraft)
+        # first filter:lateral distance
+        dxy = self.distance(np.radians(lat_birds), np.radians(lon_birds), np.radians(lat_aircraft), np.radians(lon_aircraft))
+        
+        
+        print ('dxy: ', dxy, 'crit_dist reached ', dxy < crit_dist_ac + crit_dist_b)
+        if dxy < crit_dist_ac + crit_dist_b:
+            print ("ohoh")
+            
+        
+        
+        return
+    
+    
+        
+     
+        
+    def conflict_detection(self):
+
+       # print "simt before CD", simt
+        # only run if there are birds and aircraft
+        if (len(self.birds.id) <1 ) or (len(self.traf.id) <1):
+            return
+
+
+        # once we have the first birdies, we would like to have a filename to store
+        if not self.filename_set:
+            self.birds.filename_judihui = self.filename2save
+            self.filename_set = True
+        # bring input to correct format
+        lat_birds, lon_birds, alt_birds, lat_aircraft, lon_aircraft, alt_aircraft = self.reshape()       
+
+        # first filter:lateral distance
+        dxy = self.distance(np.radians(lat_birds), np.radians(lon_birds), np.radians(lat_aircraft), np.radians(lon_aircraft))
+        #dxyqwik = self.quick_distance(np.radians(lat_birds), np.radians(lon_birds), np.radians(lat_aircraft), np.radians(lon_aircraft))
+        #print simt, self.traf.id, self.birds.id, "dist",dxy, "kwik", dxyqwik, "deltaalt",abs(alt_birds - alt_aircraft), "alt_b",alt_birds, "alt_ac",alt_aircraft
+        #print "lat b", lat_birds, "lon b", lon_birds, "lat ac", lat_aircraft, "lon ac", lon_aircraft
+        #print "rad b", self.birds.collision_radius, "rad ac", self.traf.ac_collision_radius,  "h ac", self.traf.ac_collision_height
+        #print
+        
+        # is this already in the dangerous area?
+        # input for ac is already radius (diameter/2)
+        # for birds we are fixed now: 0.5m individuals, 5m flocks
+
+        c_rad_birds = self.birds.collision_radius.reshape(len(self.birds.collision_radius), 1)
+        c_rad_ac = self.ac_collision_radius.reshape(1,len(self.ac_collision_radius))
+      #  print ('dxy', dxy, 'c_rad_birds', c_rad_birds, 'c_rad_ac', c_rad_ac, 'sum', c_rad_birds + c_rad_ac)
+        dangerous_dist = (dxy <= c_rad_birds + c_rad_ac)*1.
+       # print ('dxy', dxy, 'c_rad_birds', c_rad_birds, 'c_rad_ac', c_rad_ac, 'sum', c_rad_birds + c_rad_ac)
+        
+        # only continue for bird-ac combinations where the lateral distance is too small
+        if len(np.where(np.any(dangerous_dist == 1. , axis = 1) == True)[0]) > 0 and \
+           len(np.where(np.any(dangerous_dist == 1. , axis = 0) == True)[0]) > 0 : 
+              # print "dangerous dist"
+              
+
+               
+               # filter
+               alt_birds = alt_birds[np.where(np.any(dangerous_dist == 1. , axis = 1) == True)[0]]
+               alt_aircraft = alt_aircraft[0][np.where(np.any(dangerous_dist == 1., axis = 0) == True)[0]]
+               collision_height = self.ac_collision_height[np.where(np.any(dangerous_dist == 1. , axis = 0) == True)[0]]                
+               
+               # filter
+               lat_birds    = lat_birds[np.where(np.any(dangerous_dist == 1. , axis = 1) == True)[0]]
+               lon_birds    = lon_birds[np.where(np.any(dangerous_dist == 1. , axis = 1) == True)[0]]
+               lat_aircraft = lat_aircraft[0][np.where(np.any(dangerous_dist == 1., axis = 0) == True)[0]]
+               lon_aircraft = lon_aircraft[0][np.where(np.any(dangerous_dist == 1., axis = 0) == True)[0]]
+               
+               
+               
+               
+               # is a list and has therefore to be converted 
+               id_ac = np.array(self.traf.id)
+               # used for later
+               sweep = self.ac_collision_sweep[np.where(np.any(dangerous_dist == 1. , axis = 0) == True)[0]]
+               hdg   = self.traf.hdg[np.where(np.any(dangerous_dist == 1. , axis = 0) == True)[0]]
+               id_ac = id_ac[np.where(np.any(dangerous_dist == 1. , axis = 0) == True)[0]]
+               id_bird = self.birds.id[np.where(np.any(dangerous_dist == 1. , axis = 1) == True)[0]]
+
+
+
+
+               # altiutde difference: 
+               # only birds in the same plane as the aircraft are interesting
+               # input is already ac_height/2
+               dangerous_alt = (abs(alt_birds - alt_aircraft) <= collision_height)*1.
+              # print ('alt bird', alt_birds, 'alt ac',alt_aircraft,'collheight', collision_height, 'dangerous alt', dangerous_alt )
+               
+               # only continue if there are bird-ac combinations within 
+               #dangerous distance AND in the same altitude band
+    
+                # only continue if any birds and aircraft are in the same altitude layer
+               if len(np.where(np.any(dangerous_alt == 1. , axis = 1) == True)[0]) > 0 and \
+                  len(np.where(np.any(dangerous_alt == 1. , axis = 0) == True)[0]) > 0 :
+                    
+                    
+                    # filter
+                    lat_birds    = lat_birds[np.where(np.any(dangerous_alt == 1. , axis = 1) == True)[0]]
+                    lon_birds    = lon_birds[np.where(np.any(dangerous_alt == 1. , axis = 1) == True)[0]]
+                    
+
+                    lat_aircraft = lat_aircraft[np.where(np.any(dangerous_alt == 1., axis = 0) == True)[0]]
+                    lon_aircraft = lon_aircraft[np.where(np.any(dangerous_alt == 1., axis = 0) == True)[0]]
+                    
+
+                    sweep        = sweep[np.where(np.any(dangerous_alt == 1. , axis = 0) == True)[0]]
+                    hdg          = hdg[np.where(np.any(dangerous_alt == 1. , axis = 0) == True)[0]]
+                    id_ac        = id_ac[np.where(np.any(dangerous_alt == 1. , axis = 0) == True)[0]]
+                    id_bird      = id_bird[np.where(np.any(dangerous_alt == 1. , axis = 1) == True)[0]]
+
+            
+                    # bearing between bird and aircraft
+                    bearing = self.bearing(np.radians(lat_aircraft), np.radians(lon_aircraft), np.radians(lat_birds), np.radians(lon_birds))
+                    #print "simt", simt
+                    #print "bearing", bearing, "ac pos", lat_aircraft, lon_aircraft, "bird pos", lat_birds, lon_birds
+                    # top view of the aircraft: bird strikes only occurr if 
+                    # they take place in the front half (end is wingtip)
+                    # relative values required
+                    pacman_high = ( 90. + sweep)
+                    pacman_low  = (-90. - sweep)
+                    #print "pacmaaaan", pacman_low, pacman_high
+                    # explanation in method
+                    delta_heading = ((((hdg - bearing)%360.) + 180. + 360.)% 360.) - 180.        
+                   # print ("delta heading", delta_heading)
+                
+                    # and is it within the front area of the aircraft?
+                    # then we have a strike!
+                    pacman = ((delta_heading > pacman_low) & (delta_heading < pacman_high) )* 1.
+                    #print "pacman", pacman
+                    # which birds were hit? 
+
+                    id_hit_birds = id_bird[np.where(np.any(pacman ==1., axis = 1) == True)[0]]
+                    id_hit_ac = id_ac[np.where(np.any(pacman ==1., axis = 0) == True)[0]]
+                    #print
+                    #print "hdg aircraft", hdg
+                    #print "pacman", pacman_high, pacman_low, "delta hdg", delta_heading, "bearing",bearing
+                    
+                    # only continue if there was a strike
+                    if len(id_hit_birds) > 0:
+                        strike_time = bs.sim.simt
+
+                        idx_birds_hit = []
+                        bird_data = []
+                        lat_birds = []
+                        lon_birds = []
+                        
+                        for identity in id_hit_birds:
+                            # this is the index in the class birds
+                            index_birds = int(np.where(self.birds.id == float(identity))[0][0])
+                            idx_birds_hit.append(index_birds) 
+                            lat_birds.append(self.birds.lat[index_birds])
+                            lon_birds.append(self.birds.lon[index_birds])
+                            
+                            bird_data.append(str(self.birds.id[index_birds]) + ' \t ' +  str(self.birds.tas[index_birds]) \
+                                              + ' \t ' + str(self.birds.lat[index_birds]) + ' \t ' +  str(self.birds.lon[index_birds]) \
+                                              + ' \t ' + str(self.birds.alt[index_birds]) + ' \t ' + str(self.birds.bird_size[index_birds])\
+                                              + ' \t ' + str(self.birds.collision_radius[index_birds]) + ' \t ' + str(self.birds.no_inds[index_birds]) \
+                                              + ' \t ' + str(self.birds.flock_flag[index_birds]))   
+                        
+                            # log data
+                            #self.log.write(str(strike_time), "BIRD", str(self.birds.id[index_birds]),\
+                            #                str(self.birds.tas[index_birds]), str(self.birds.lat[index_birds]), \
+                             #               str(self.birds.lon[index_birds]), str(self.birds.alt[index_birds]), \
+                             #               str(self.birds.cat[index_birds]), str(self.birds.flock_flag[index_birds]), \
+                               #             "BUFFER")
+                                                                    
+                            
+                        
+                        # remove them        
+                        self.birds.remove_bird(idx_birds_hit)
+
+          
+                        # store IDs of hit aircraft
+                        #id_hit_ac = id_ac[np.where(np.any(pacman ==1., axis = 0) == True)[0]]
+
+                        
+                        # increase counter
+                        self.counter_strikes = self.counter_strikes + len(id_hit_ac)
+
+                        #  store the aircraft id's of the hit aircraft - preparation
+                        to_mark = []
+                        for identity in id_hit_ac:
+
+                            if identity in self.traf.id:
+                                to_mark.append(int(np.where(np.array(self.traf.id) == identity)[0][0]))
+                        to_mark = np.unique(to_mark)
+                       
+                        # store the aircraft indices of the hit aircraft - execution 
+                        # idx is the index of the array: 0:n
+                        # pos is the value of to_mark at the index - in this case
+                        # it marks the position of the aircraft within the hit_ac array
+                        
+                        for idx in to_mark:
+
+                            
+                            ac_data = str(self.traf.id[idx]) + ' \t ' + str(self.traf.tas[idx]) \
+                             + ' \t ' + str(self.traf.lat[idx]) + ' \t ' + str(self.traf.lon[idx]) \
+                             + ' \t ' + str(self.traf.alt[idx]) + ' \t ' + str(self.traf.type[idx])
+                            
+                            # which bird did this aircraft hit?
+                            # determination via lat-lon difference (max. 0.001 resp.)
+                            for i in range(len(idx_birds_hit)):
+
+                                if (abs(self.traf.lat[idx] - lat_birds[i]) < 0.001) and \
+                                    (abs(self.traf.lon[idx] - lon_birds[i] < 0.001)):
+
+                                        #self.log.write(self.birds.filename2save, str(strike_time), ac_data, bird_data[i], "collision")
+                                        self.log.write(self.birds.filename_judihui, str(strike_time), ac_data, bird_data[i], "collision")
+
+
+                                        
+                            # log data
+                           # self.log.write(str(strike_time), "AIRCRAFT", str(self.traf.id[idx]), str(self.traf.tas[idx]), \
+                            #               str(self.traf.lat[idx]), str(self.traf.lon[idx]), str(self.traf.alt[idx]), str(self.traf.type[idx]), \
+                             #              str(self.traf.orig[idx]), str(self.traf.dest[idx]))
+                                           
+                         # write: str(strike_time), aircraft, bird --> header true/false?
+
+
+
+                        # store the aircraft id's as well
+                        # even if an aircraft has more than one strike: we only want to store it's id once
+                        # np.in1d: is arg1 in arg2?
+                        #new_id_hit_ac = id_hit_ac[np.where(np.in1d( id_hit_ac, self.traf.nr_strikes, invert = True))]        
+                        #self.traf.nr_strikes = np.append(self.traf.nr_strikes, new_id_hit_ac)
+                        #print "traf_strikes", self.traf.nr_strikes
+
+                    # log data of collision
+                        
+
+                        #self.log.save(self.birds.filename2save) 
+                        self.log.save(self.birds.filename_judihui)
+                        print('saved', self.birds.filename_judihui)
+
+
+
+
+
+        
+    
+        return 
+
+
+
+    # format input for calculation
+    # hint: name the reshapes differently oooooooor make an individual module
+    # individual module might have adavantages as there are inputs from traf. and from birds.
+    # height and radius of aircraft: store in input_files or find ways to get it via other parameters
+    def reshape(self):
+
+
+        # birds are the columns, aircraft are the rows
+        lat_birds = self.birds.lat.reshape((len(self.birds.lat),1))
+        lon_birds = self.birds.lon.reshape((len(self.birds.lon),1))
+        alt_birds = self.birds.alt.reshape((len(self.birds.alt),1))
+
+        
+        lat_aircraft = self.traf.lat.reshape((1,len(self.traf.lat)))
+        lon_aircraft = self.traf.lon.reshape((1,len(self.traf.lon)))
+        alt_aircraft = self.traf.alt.reshape((1,len(self.traf.alt)))        
+        
+        
+        
+        return lat_birds, lon_birds, alt_birds, lat_aircraft, lon_aircraft, alt_aircraft
+        
+        
+    # use the haversine formula to calculate the distance between birds and ac    
+    # input is already in radians
+    def distance(self, lat_birds, lon_birds, lat_ac, lon_ac):
+
+
+        
+        a = np.sin((lat_birds-lat_ac)/2)*np.sin((lat_birds-lat_ac)/2) + \
+            np.cos(lat_birds)*np.cos(lat_ac)*np.sin((lon_birds-lon_ac)/2)*np.sin((lon_birds-lon_ac)/2)
+   
+        c= 2*np.arctan2(np.sqrt(a), np.sqrt(1-a))
+        distance= earth_radius*c # 6317000m corresponds to the earth radius
+
+        
+        return distance
+
+
+    def quick_distance(self,lat_birds, lon_birds, lat_ac, lon_ac):
+        '''a bit less accurracy but sooooo much faster '''
+        dx = earth_radius * (lon_birds - lon_ac) * self.coslat
+        dy = earth_radius * (lat_birds - lat_ac)
+        distance = np.sqrt(dx*dx + dy*dy)
+        
+        return distance
+
+
+
+    def bearing(self, lat1, lon1, lat2, lon2):
+    
+        deltal = lon2-lon1
+    
+    # calculate runway bearing
+        bearing = np.arctan2(np.sin(deltal)*np.cos(lat2), (np.cos(lat1)*np.sin(lat2)-
+                np.sin(lat1)*np.cos(lat2)*np.cos(deltal)))
+        
+        # normalize to 0-360 degrees
+        bearing = (np.degrees(bearing)+360)%360
+        
+        return bearing
+
+
+class Datalog():
+    def __init__(self):
+        print ("we are in CDR datalog")
+# Create a buffer and save filename
+
+        self.buffer=[]
+        
+        #filename will be set in first run
+        self.filename_flag = False
+
+         
+        return
+    
+    def write(self, filename,time, ac_data, bird_data, occurrence_type):
+
+
+        # filename[5:15] is the date
+        self.buffer.append( filename +" \t "  + time +" \t " + ac_data + " \t " + bird_data + '\t' + occurrence_type + chr(13) + chr(10))
+       
+        return
+
+    def save(self, filename):
+        
+        # files are saved per airport. Hence only create a new file if 
+        # no file for this airport exists
+        log_file = os.path.join(dir, "bird_CDR_log/"  + filename + ".txt" )
+        print ('in save, logpath is', log_file)
+        if not os.path.isfile(log_file):  
+           # log_file = "log/" + filename_def + ".txt"
+           # self.log_file = os.path.join(dir, log_file)
+            #print "INIT", filename_def, filename, log_file
+            
+            with open(log_file, "a") as writeto:
+                writeto.write('date \t time \t id_ac \t tas \t lat \t lon \t alt \t type \t id_bird \t tas \t lat \t lon \t alt \t size \t coll_rad \t number \t flock_flag \t occurrence type \n')
+        
+        
+       # if not self.filename_flag:
+          #  filename = "log/" + filename + ".txt"
+            
+           # self.filename = os.path.join(dir,  filename)
+
+            # write the header            
+            #with open(self.filename, "a") as writeto:
+            #    writeto.write('time \t id_ac \t tas \t lat \t lon \t alt \t type \t orig \t dest id_bird \t tas \t lat \t lon \t alt \t size \t coll_rad \t number \t flock_flag \n')
+
+            #self.filename_flag = True
+
+# Write buffer to file 
+
+        with open(log_file, "a") as writeto:
+            for i in range(len(self.buffer)):
+
+                writeto.write(self.buffer[i])
+
+
+        self.buffer = []    
+        
+
+
+        
+        
+        
+        
+        return
+   
diff --git a/bluesky/plugins/glbirds.py b/bluesky/plugins/glbirds.py
new file mode 100644
index 00000000..43b13108
--- /dev/null
+++ b/bluesky/plugins/glbirds.py
@@ -0,0 +1,175 @@
+""" Bird traffic gui plugin """
+import numpy as np
+
+import bluesky as bs
+from bluesky import ui 
+from bluesky.ui import palette
+from bluesky import settings
+import bluesky.ui.qtgl.glhelpers as glh
+from bluesky.tools.aero import ft
+from bluesky.ui.qtgl.guiclient import UPDATE_ALL
+
+# Register settings defaults
+settings.set_variable_defaults(text_size=13, bird_size=10)
+
+palette.set_default_colours(
+    bird=(255, 255, 0))
+
+# Static
+MAX_NBIRDS = 10000
+
+### Initialization function of your plugin.
+def init_plugin():
+    config = {
+        'plugin_name':     'BIRDGUI',
+        'plugin_type':     'gui',
+        }
+
+    return config
+
+# Bird traffic class
+class BirdTraffic(ui.RenderObject, layer=100):
+    # TODO: FIX labels
+    def __init__(self, parent):
+        super().__init__(parent=parent)
+        
+        self.bird_trk = glh.GLBuffer()
+        self.bird_lat = glh.GLBuffer()
+        self.bird_lon = glh.GLBuffer()
+        self.bird_alt = glh.GLBuffer()
+        self.bird_color = glh.GLBuffer()
+        self.bird_lbl = glh.GLBuffer()
+        self.bird_symbol = glh.VertexArrayObject(glh.gl.GL_TRIANGLE_FAN)
+        self.birdlabels = glh.Text(settings.text_size, (8, 3))
+        self.nbirds = 0
+        self.show_lbl = True
+
+        # subscribe to BIRDDATA stream only from active node
+        bs.net.subscribe(b'BIRDDATA', actonly=True)
+        
+        # connect the stream to bird catcher
+        bs.net.stream_received.connect(self.bird_catcher)
+
+        # get stream of actnodedata changed to reset birds
+        bs.net.actnodedata_changed.connect(self.bird_reset)
+
+    def create(self):
+        
+        bird_size = settings.bird_size
+        self.bird_trk.create(MAX_NBIRDS * 4, glh.GLBuffer.StreamDraw)
+        self.bird_lat.create(MAX_NBIRDS * 4, glh.GLBuffer.StreamDraw)
+        self.bird_lon.create(MAX_NBIRDS * 4, glh.GLBuffer.StreamDraw)
+        self.bird_alt.create(MAX_NBIRDS * 4, glh.GLBuffer.StreamDraw)
+        self.bird_color.create(MAX_NBIRDS * 4, glh.GLBuffer.StreamDraw)
+        self.bird_lbl.create(MAX_NBIRDS * 24, glh.GLBuffer.StreamDraw)
+
+
+        # ------- Bird triangle fan -------------------------
+        birdvertices = np.array([(0.0, 0.0),                     # 1
+                            (0.7 * bird_size, -0.1 * bird_size),   # wing, 2 
+                            (0.7 * bird_size, 0.1 * bird_size),    # wing, 3
+                            (0.25 * bird_size, 0.1 * bird_size),    # trans, 4
+                            (0.1 * bird_size, 0.1 * bird_size),    # trans 5
+                            (0.05 * bird_size, 0.5 * bird_size),    #head. 6
+                            (-0.05 * bird_size, 0.5 * bird_size),    #head. 7
+                            (-0.1 * bird_size, 0.1 * bird_size),    # trans 8
+                            (-0.25 * bird_size, 0.1 * bird_size),    # trans, 9
+                            (-0.7 * bird_size, 0.1 * bird_size),    # wing, 10
+                            (-0.7 * bird_size, -0.1 * bird_size),   # wing, 11
+                            (-0.25 * bird_size, -0.1 * bird_size),   # trans, 12 
+                            (0, -0.5 * bird_size),   # tail, 13
+                            (0.25 * bird_size, -0.1 * bird_size),   # trans, 14 
+                            (0.7 * bird_size, -0.1 * bird_size)],
+                        dtype=np.float32)
+
+        self.bird_symbol.create(vertex=birdvertices)
+
+        self.bird_symbol.set_attribs(lat=self.bird_lat, lon=self.bird_lon, color=self.bird_color,
+                                   orientation=self.bird_trk, instance_divisor=1)
+
+        self.birdlabels.create(self.bird_lbl, self.bird_lat, self.bird_lon, self.bird_color,
+                             (bird_size, -0.5 * bird_size), instanced=True)
+
+    def draw(self):
+        #print ('GL - bird drawing')
+        if self.nbirds:
+            self.bird_symbol.draw(n_instances=self.nbirds)
+
+        # TODO: fix label
+        # if self.show_lbl:
+        #     self.birdlabels.draw(n_instances=self.nbirds)
+
+    def update_bird_data(self, data):
+        #print ('GL - bird updating', data['id'])
+        
+        # get bird data
+        bird_id = data['id']
+       # bird_type = data['type']
+        bird_lat = data['lat']
+        bird_lon = data['lon']
+        bird_trk = data['trk']
+        bird_alt = data['alt']
+       # bird_vs = data['vs']
+       # bird_hs = data['hs']
+
+        # update buffers
+        self.nbirds = len(bird_lat)
+        self.bird_lat.update(np.array(bird_lat, dtype=np.float32))
+        self.bird_lon.update(np.array(bird_lon, dtype=np.float32))
+        self.bird_trk.update(np.array(bird_trk, dtype=np.float32))
+        self.bird_alt.update(np.array(bird_alt, dtype=np.float32))
+
+        # colors
+        rawlabel = ''
+        color = np.empty(
+            (min(self.nbirds, MAX_NBIRDS), 4), dtype=np.uint8)
+        rgb_bird = palette.bird
+
+        zdata = zip(data['id'], data['alt'])
+        for i, (id, alt) in enumerate(zdata):
+            if i >= MAX_NBIRDS:
+                break
+
+            # Make label
+            if self.show_lbl:
+                #print ("in gl, birdie id is", id, type(id), len(str(id)))
+                #print ("spooky abbreviation", '%-8s')
+                rawlabel += '%-8s' % str(id)[:8]
+                rawlabel += '%-5d' % int(alt / ft + 0.5)
+
+            color[i, :] = tuple(rgb_bird) + (255,)
+        
+        # update bird label
+        self.bird_color.update(color)
+        self.bird_lbl.update(np.array(rawlabel.encode('utf8'), dtype=np.string_))
+
+    def bird_catcher(self, name, data, sender_id):
+        """receive stream from bluesky sim.
+        """
+        #print ('GL - catching birdies')
+        # update bird data if stream is bird data
+        if name == b'BIRDDATA':
+            self.update_bird_data(data)
+
+    def bird_reset(self, nodeid, nodedata, changed_elems):
+        """Receive signal from actnodedata_changed.
+        When changed_elems is equal to UPDATE_ALL from gui client 
+        it signals a reset or a new node.
+        """
+        #print('GL - bird reset is called')
+        # reset birds if changing to a new active node
+        if changed_elems == UPDATE_ALL:
+            
+            data = dict()
+
+            data['id']         =[]
+            data['type']       = []
+            data['lat']        = []
+            data['lon']        = []
+            data['alt']        = []
+            data['trk']        = []
+            data['vs']         = []
+            data['hs']         = []
+
+            self.update_bird_data(data)
+        
\ No newline at end of file
diff --git a/bluesky/plugins/logger.py b/bluesky/plugins/logger.py
index 5745aef1..8b7b9ce1 100644
--- a/bluesky/plugins/logger.py
+++ b/bluesky/plugins/logger.py
@@ -59,11 +59,24 @@ confparamheader = \
     'latitude_ac2[deg],' + \
     'longitude_ac2[deg],' + \
     'altitude_ac2[ft],' + \
+    'heading_ac1[deg],' + \
+    'heading_ac2[deg],' + \
+    'vs_ac1[fpm],' + \
+    'vs_ac2[fpm],' + \
     'dcpa[nm],' + \
     'tcpa[sec],' + \
     'tLOS[sec],' + \
-    'qdr[-],' + \
-    'dist[-]\n'
+    'qdr[deg],' + \
+    'dist[nm],' +\
+    'tinconf[sec],' + \
+    'toutconf[sec],' + \
+    'dalt_min[ft]\n'
+
+confseverheader = \
+    'simt[s],' + \
+    'ac1,' + \
+    'ac2,' + \
+    'duration[s]\n'
 
 
 ### Initialization function of your plugin. Do not change the name of this
@@ -113,11 +126,19 @@ class Logger(Entity):
         # Parameters for conflict count and statistics
         self.prevconfpairs = set()      #counter for all conflicts already listed
         self.conf_all = 0               #counter for all conflicts
+        self.duration = {}              #dict for duration values
+
+        # new severity parameters
+        self.min_dcpa = {}    # Track minimum dcpa for each conflict
+        self.min_dalt = {}    # Track minimum dalt for each conflict
+        self.tinconf = {}     # Track conflict start times for each conflict
+        self.toutconf = {}    # Track conflict end times for each conflict
 
         # The FLST & CONF & CONFPARAM logger
         self.flst = datalog.crelog('FLSTLOG', None, flstheader)
         self.conflog = datalog.crelog('CONFLOG', None, confheader)
         self.confparamlog = datalog.crelog('CONFPARAMLOG', None, confparamheader)
+        self.confseverlog = datalog.crelog('CONFSEVERLOG', None, confseverheader)
 
         with self.settrafarrays():
             self.distance2D = np.array([])
@@ -128,6 +149,13 @@ class Logger(Entity):
         super().reset()
         self.prevconfpairs = set()
         self.conf_all = 0
+        self.duration = {}
+
+        # severity parameters
+        self.min_dcpa = {}
+        self.min_dalt = {}
+        self.tinconf = {}
+        self.toutconf = {}
 
 
     def create(self, n=1):
@@ -159,7 +187,11 @@ class Logger(Entity):
 
         # Boolean array to track which aircraft have valid destinations
         valid_dest = np.ones(traf.ntraf, dtype=bool)  # Start by assuming all destinations are valid
-
+        
+        
+        #########################################################
+        ################## DELETE IF LANDED #####################
+        #########################################################
         # Precompute destination latitudes and longitudes for all aircraft
         for idx, apname in enumerate(dest_names):
             apidx = bs.navdb.getaptidx(apname)
@@ -187,7 +219,7 @@ class Logger(Entity):
         # Now compute the distances between each aircraft and its destination
         _, distances = geo.qdrdist(lat_ac[valid_dest], lon_ac[valid_dest], lat_dest[valid_dest], lon_dest[valid_dest])
 
-        # Vectorized deletion: Find indices where the distance is less than 10
+        # Vectorized deletion: Find indices where the distance is less than 10nm
         d = 10
         to_delete_valid = np.where(distances < d)[0]
 
@@ -196,52 +228,63 @@ class Logger(Entity):
 
         # Delete the aircraft all at once
         for idx in to_delete:
+            cs = traf.id[idx]
             traf.delete(idx)
-            cs = traf.id(idx)
-            print(f"aircraft {cs} number {idx} deleted. Distance to destination: {d} NM.")
-
-        # DELETE
-        # check for all aircraft in traffic array  von 0 bis size ntraf
-        #to_delete = []
-        #for idx in range(traf.ntraf):
-        # actual position
-            #csn = traf.id
-            #lat_ac = traf.lat[idx]
-            #lon_ac = traf.lon[idx]
-            #apname = traf.ap.dest[idx]
-            #apidx = bs.navdb.getaptidx(apname)
-            #route = traf.ap.route[idx]
-            
-            #if apidx < 0:
-                #if bs.traf.ap.route[idx].nwp > 0:
-                    #reflat = bs.traf.ap.route[idx].wplat[-1]
-                    #reflon = bs.traf.ap.route[idx].wplon[-1]
-                #else:
-                    #reflat = bs.traf.lat[idx]
-                    #reflon = bs.traf.lon[idx]
-
-                #success, posobj = txt2pos(apname, reflat, reflon)
-                #if success:
-                    #lat_dest = posobj.lat
-                    #lon_dest = posobj.lon
-                #if not success:
-                    #print("DEST: Position " + apname + " not found.")
-                    #continue
-            #else:
-                #lat_dest = bs.navdb.aptlat[apidx]
-                #lon_dest = bs.navdb.aptlon[apidx]
-        # criterion for distance and delete if true
-            #q, d = geo.qdrdist(lat_ac, lon_ac, lat_dest, lon_dest)
-            #if d < 10:
-               #to_delete.append(idx)
-
-        # After checking aircraft, delete the aircraft
-        #for idx in to_delete:
-            #traf.delete(idx)
-            #print(f"aircraft {csn} number {idx} deleted. Distance to destination: {d} NM.")
+            print(f"LOGGER: aircraft {cs} [idx: {idx}] landed")
+        
+        
+        #################################################################
+        ################## CONFLICT PAIRS PARAMETER #####################
+        #################################################################
+        #check for new conflict pairs
+        confpairs_new = list(set(traf.cd.confpairs) - self.prevconfpairs)
+        if confpairs_new:
+            processed_conflicts = set()
+            idxdict = {v: i for i, v in enumerate(traf.cd.confpairs)}
+
+            for pair in confpairs_new:
+                confpair_frozen = frozenset(pair)
+                if confpair_frozen not in processed_conflicts:
+                    i = idxdict[pair]
+                    
+                    dcpa_new = np.asarray(traf.cd.dcpa)[i]
+                    tcpa_new = np.asarray(traf.cd.tcpa)[i]
+                    tLOS_new = np.asarray(traf.cd.tLOS)[i]
+                    qdr_new = np.asarray(traf.cd.qdr)[i]
+                    dist_new = np.asarray(traf.cd.dist)[i]
+                    dalt_new = abs(traf.alt[traf.id2idx(pair[0])] - traf.alt[traf.id2idx(pair[1])])
 
+                    ac1, ac2 = pair
+                    idx1 = traf.id2idx(ac1)
+                    idx2 = traf.id2idx(ac2)
+                    
+                    lat_1, lon_1, alt_1, hdg_1, vs_1 = traf.lat[idx1], traf.lon[idx1], traf.alt[idx1], traf.hdg[idx1], traf.vs[idx1]/fpm
+                    lat_2, lon_2, alt_2, hdg_2, vs_2 = traf.lat[idx2], traf.lon[idx2], traf.alt[idx2], traf.hdg[idx2], traf.vs[idx2]/fpm
+                    
+                    # Initialize tracking values if the conflict is new
+                    if confpair_frozen not in self.min_dcpa:
+                        self.min_dcpa[confpair_frozen] = dcpa_new
+                        self.min_dalt[confpair_frozen] = dalt_new
+                        self.tinconf[confpair_frozen] = sim.simt
+                    else:
+                        # Update minimum dcpa and dalt if the current values are lower
+                        self.min_dcpa[confpair_frozen] = min(self.min_dcpa[confpair_frozen], dcpa_new)
+                        self.min_dalt[confpair_frozen] = min(self.min_dalt[confpair_frozen], dalt_new)
+
+                    # Log the parameters
+                    self.confparamlog.log(
+                        ac1, ac2, lat_1, lon_1, alt_1/ft, lat_2, lon_2, alt_2/ft, hdg_1, hdg_2, vs_1, vs_2,
+                        self.min_dcpa[confpair_frozen] / nm, tcpa_new, tLOS_new, qdr_new, dist_new / nm,
+                        self.tinconf[confpair_frozen], sim.simt, self.min_dalt[confpair_frozen] / ft
+                    )
+                    
+                    processed_conflicts.add(confpair_frozen)
+                    self.conf_all += 1
+                    self.conflog.log(self.conf_all)
 
-        #check for new conflict pairs
+        self.prevconfpairs = set(traf.cd.confpairs)
+        
+        '''
         confpairs_new = list(set(traf.cd.confpairs) - self.prevconfpairs)
         if confpairs_new:
 
@@ -251,6 +294,7 @@ class Logger(Entity):
             # Mapping conflict pairs to their index in the original list
             idxdict = {v: i for i, v in enumerate(traf.cd.confpairs)}
     
+            
             for pair in confpairs_new:
                 # Use frozenset to ensure the conflict pair is considered in a unique way (order-independent)
                 confpair_frozen = frozenset(pair)
@@ -261,7 +305,7 @@ class Logger(Entity):
             
                     # Retrieve parameters for the conflict pair
                     dcpa_new = np.asarray(traf.cd.dcpa)[i]
-                    tcpa_new = np.asarray(traf.cd.tcpa)[i]
+                    tcpa_new = np.asarray(traf.cd.tcpa)[i] #Time to closest point of approach (CPA) between aircraft
                     tLOS_new = np.asarray(traf.cd.tLOS)[i]
                     qdr_new = np.asarray(traf.cd.qdr)[i]
                     dist_new = np.asarray(traf.cd.dist)[i]
@@ -274,13 +318,13 @@ class Logger(Entity):
                     idx2 = traf.id2idx(ac2)
                     
                     # Get positions for both aircraft
-                    lat_1, lon_1, alt_1 = traf.lat[idx1], traf.lon[idx1], traf.alt[idx1]
-                    lat_2, lon_2, alt_2 = traf.lat[idx2], traf.lon[idx2], traf.alt[idx2]
+                    lat_1, lon_1, alt_1, hdg_1, vs_1 = traf.lat[idx1], traf.lon[idx1], traf.alt[idx1], traf.hdg[idx1], traf.vs[idx1]/fpm
+                    lat_2, lon_2, alt_2, hdg_2, vs_2 = traf.lat[idx2], traf.lon[idx2], traf.alt[idx2], traf.hdg[idx2], traf.vs[idx2]/fpm
                     
                     # Log conflict parameters
                     self.confparamlog.log(
-                        ac1, ac2, lat_1, lon_1, alt_1/ft, lat_2, lon_2, alt_2/ft,
-                        dcpa_new, tcpa_new, tLOS_new, qdr_new, dist_new
+                        ac1, ac2, lat_1, lon_1, alt_1/ft, lat_2, lon_2, alt_2/ft, hdg_1, hdg_2, vs_1, vs_2,
+                        dcpa_new / nm, tcpa_new, tLOS_new, qdr_new, dist_new / nm
                     )
             
                     # Mark the conflict as processed
@@ -292,15 +336,52 @@ class Logger(Entity):
 
         # Update the set of previous conflict pairs
         self.prevconfpairs = set(traf.cd.confpairs)
+        '''
+
+        ##########################################################
+        ################## CONFLICT DURATION #####################
+        ########################################################## 
+        # 
+        # - conflicts still ongoing when simulation ends are not logged
+        #       
+        # Loop through each conflict pair in traf.cd.confpairs
+        for pair in traf.cd.confpairs:
+        # If the conflict pair is new, initialize its duration to 1
+            # Use frozenset to store unique pairs in duration dictionary
+            unique_pair = frozenset(pair)
+            if unique_pair not in self.duration:
+                self.duration[unique_pair] = 1
+            else:
+                # If the conflict pair already exists, its duration has already started tracking
+                continue
+
+        # Now, loop through each pair in the duration dictionary
+        for pair, duration in list(self.duration.items()):  # Use list() to allow modifying the dict during iteration
+            confpair_frozen = frozenset(pair)
+
+            # Check if the pair is still part of traf.cd.confpairs_unique
+            if confpair_frozen in traf.cd.confpairs_unique:
+                # Conflict is still ongoing, increment the duration by 1
+                self.duration[pair] += 1
+            else:
+                # Conflict has ended, log the pair and its duration
+                ac1, ac2 = tuple(pair) # Unpack frozenset to individual aircraft IDs
+                self.confseverlog.log(ac1, ac2, self.duration[pair])
+
+                # Remove the pair from the duration dictionary as it is no longer active
+                del self.duration[pair]
+                self.toutconf[confpair_frozen] = sim.simt  # Log conflict end time
 
+        
 
+        ################## FLIGHT STATUS LOG #####################
         #log flight statistics
         self.flst.log(
             traf.id, #callsign
             traf.type, #aircraft type
             self.create_time, #creation time [s]
             sim.simt - self.create_time, #flight time [s]
-            traf.distflown, #distance flown [nm]
+            traf.distflown/nm, #distance flown [nm]
             self.distance2D, #actual distance 2D [nm]
             self.distance3D, #actual distance 3D [nm]
             traf.work*1e-6, #work done [MJ]
@@ -324,10 +405,11 @@ class Logger(Entity):
             
 
     def start_log(self):
-        print ("FLST and CONF logger started")
+        print ("LOGGER: FLST and CONF logger started")
         self.flst.start()
         self.conflog.start()
         self.confparamlog.start()
+        self.confseverlog.start()
         #'FLST and CONF logger started'
         return True, f'FLST and CONF logger is ON'
 
diff --git a/bluesky/plugins/randomize_birdies.py b/bluesky/plugins/randomize_birdies.py
new file mode 100644
index 00000000..2cbc501a
--- /dev/null
+++ b/bluesky/plugins/randomize_birdies.py
@@ -0,0 +1,176 @@
+# -*- coding: utf-8 -*-
+"""
+Created on Sat Sep 23 15:05:13 2017
+
+@author: Isabel
+"""
+import numpy as np
+import pandas as pd
+
+def randomize_birds(seed, filename):
+
+    
+    # first get the file
+    #df = pd.read_csv('bird_movement_plan.csv', sep = "\t", \
+    #                     names = ['id', 'time', 'lon','lat', 'alt', 'size', 'number', 'ff',\
+    #                     'id1', 'spd', 'hdg'], index_col = False)
+    
+    df = pd.read_csv(filename, sep = "\,", \
+                         names = ['id', 'date', 'lon','lat', 'alt', 'cat', 'no_individuals', 'flock_flag',\
+                         'id1', 'hdg', 'spd', 'lat_s1', 'lat_n1', 'lon_w1', 'lon_e1','lat_s2', 'lat_n2', 'lon_w2', 'lon_e2'], index_col = False, engine = 'python')
+
+
+    #print "at init", df['id']
+    # place the seed
+    np.random.seed(seed)
+    
+    # make sure that we only use the first occurrence of every birdie :)
+    df['duplicate'] =  df.duplicated(['id'])
+    
+    # df1 id the one with the first occurrences
+    df1 = df[df.duplicated(['id']) == False]
+    # df2 are the ones to follow
+    df2 = df[df.duplicated(['id']) == True]
+
+    
+    # altitude
+        
+        # for all birdies
+        
+        # BUT ONLY FOR FIRST OCCURRENCE OF EVERY BIRD
+    
+        
+        # respective altitude band --> check if the inclusive is at lower or upper boundary
+        
+        # 0-200
+    mask = (df1['alt'] > 0.) & (df1['alt'] <= 200.)
+    
+    
+    
+    df1.loc[mask, 'alt'] = np.random.uniform(0., 200., len(df1.loc[mask, 'alt']))
+    
+    
+        
+        # 200-400
+    mask = (df1['alt'] > 200.) & (df1['alt'] <= 400.)
+    
+    df1.loc[mask, 'alt'] = np.random.uniform(200., 400., len(df1.loc[mask, 'alt']))    
+        # 400-600
+    mask = (df1['alt'] > 400.) & (df1['alt'] <= 600.)
+    
+    df1.loc[mask, 'alt'] = np.random.uniform(400., 600., len(df1.loc[mask, 'alt']))       
+        # 600-800
+    mask = (df1['alt'] > 600.) & (df1['alt'] <= 800.)
+    
+    df1.loc[mask, 'alt'] = np.random.uniform(600., 800., len(df1.loc[mask, 'alt']))       
+        # 800-1000
+    mask = (df1['alt'] > 800.) & (df1['alt'] <= 1000.)
+    
+    df1.loc[mask, 'alt'] = np.random.uniform(800., 1000., len(df1.loc[mask, 'alt']))   
+    # latitude and longitude
+    
+        #   only for weather radar birdies (alt >=200m)
+    
+        #    creates in the field: lat_south, lat_north, lon_west, lon_east
+    
+        #   fly-in birdies: within their field... Add parameters? Then we need to add them everywhere (or is empty)
+    
+    
+    # speed: only weather radar birdies (alt >=200m) 
+    
+            #  plusminus 6 around input value
+    
+    df1['spd_low'] = df1['spd'] - 6.
+    # careful: spd_low can become negative. Where this happens, spd_low is replaced with spd
+    mask = df1['spd_low'] <= 0.
+
+    df1.loc[mask, 'spd_low'] = df1['spd']
+    df1['spd_high'] = df1['spd'] + 6.
+    
+
+    #df1.loc['alt' > 200., 'spd'] = np.random.uniform(df1['spd_low'], df1['spd_high'], len(df1.loc['alt' > 200., 'spd']))
+    #df1.loc[(df1['alt'] > 200.),'spd_new'] = np.random.uniform(df1['spd_low'], df1['spd_high'], len(df1.loc[df1['alt'] > 200.]))
+    
+    # HAS TO BE spd EVENTUALLY!!!!
+    df1['spd_new'] = np.random.uniform(df1['spd_low'], df1['spd_high'], len(df1))
+    df1.loc[(df1['alt'] > 200.),'spd'] = df1['spd_new']
+    
+    # remove non-needed columns
+    del df1['spd_new']
+    del df1['spd_low']
+    del df1['spd_high']
+    
+    
+    # direction: only weather radar birdies (alt >=200m) 
+    
+            # TAKE CARE OF 360 degrees!!!
+            # plusminus 45 degrees from init value
+            # standard deviation for heading is plusminus 45 degrees
+    df1.loc[(df1['alt'] > 200.), 'random_hdg'] = np.random.uniform(-45., 45., len(df1.loc[df1['alt'] > 200.]))       
+    df1.loc[(df1['alt'] > 200.), 'hdg'] = (df1['random_hdg'] + df1['hdg'] + 360.) % 360
+    
+    
+    
+    df1 = df1.drop(['random_hdg'], axis = 1)
+    
+    
+    # latitude and longitude: only for weather radar birdies
+    #  first: set minima and maxima for lat and lon. 
+    # Random choice because for birds flying in diagonally (e.g from North-West)
+    # can do so from two directions (North or West in this case)
+    # it is a 50:50 chance from which side they come.
+    # birds from one side or within the area: 1- and 2-values are identical
+    
+    # pairwise needed... either it is lat_s1, lat_n1, lon_w1, lon_e1 OR lat_s2, lat_n2, lon_w2, lon_e2
+    df1['designator'] = np.random.choice([1,2], len(df1))
+    
+    # pair 1
+    df1.loc[(df1['designator'] == 1), 'lat'] =np.random.uniform(df1.loc[(df1['designator'] == 1), 'lat_s1'], df1.loc[(df1['designator'] == 1), 'lat_n1'], len(df1.loc[df1['designator'] == 1]))
+    df1.loc[(df1['designator'] == 1), 'lon'] = np.random.uniform(df1.loc[(df1['designator'] == 1), 'lon_w1'], df1.loc[(df1['designator'] == 1), 'lon_e1'], len(df1.loc[df1['designator'] == 1]))
+    
+    # pair 2
+    df1.loc[(df1['designator'] == 2), 'lat'] =np.random.uniform(df1.loc[(df1['designator'] == 2), 'lat_s2'], df1.loc[(df1['designator'] == 2), 'lat_n2'], len(df1.loc[df1['designator'] == 2]))
+    df1.loc[(df1['designator'] == 2), 'lon'] = np.random.uniform(df1.loc[(df1['designator'] == 2), 'lon_w2'], df1.loc[(df1['designator'] == 2), 'lon_e2'], len(df1.loc[df1['designator'] == 2]))
+    
+    
+    
+    
+    
+    
+    
+    # remove non-needed columns
+    df1 = df1.drop(['lat_s1', 'lat_s2', 'lat_n1', 'lat_n2', 'lon_w1', 'lon_w2', 'lon_e1', 'lon_e2','duplicate', 'designator'], axis = 1)
+    df2 = df2.drop(['lat_s1', 'lat_s2', 'lat_n1', 'lat_n2', 'lon_w1', 'lon_w2', 'lon_e1', 'lon_e2', 'duplicate'], axis = 1)
+    
+  #  print "before merging",df1['id']
+    
+    
+    
+    # merge the frames back together
+    
+    df_merged = pd.concat([df1, df2])
+
+    # for the "next_ts", lat, lon, alt, we need to shift the respective cells
+    # BUT FIRST SORT CORRECTLY!
+    df_merged = df_merged.sort_values(['id','date' ], ascending=[True, True])
+
+    df_merged['timeshift'] = df_merged['date'].shift(-1)
+    df_merged['latshift'] = df_merged['lat'].shift(-1)
+    df_merged['lonshift'] = df_merged['lon'].shift(-1)    
+
+
+    #why not directly convert?
+
+    df_merged['lat']      = np.radians(df_merged['lat'])
+    df_merged['lon']      = np.radians(df_merged['lon'])
+    df_merged['latshift'] = np.radians(df_merged['latshift'])
+    df_merged['lonshift'] = np.radians(df_merged['lonshift'])    
+    
+    df_merged = df_merged.sort_values(by='date') 
+   # print "end of randomizing ", df_merged['id']
+    
+    return df_merged
+    
+    
+#df = randomize_birds(42, "bla")
+#print df
diff --git a/bluesky/plugins/windecmwf.py b/bluesky/plugins/windecmwf.py
index ee7cf101..d68fe9e6 100644
--- a/bluesky/plugins/windecmwf.py
+++ b/bluesky/plugins/windecmwf.py
@@ -98,7 +98,7 @@ class WindECMWF(WindSim):
     def extract_wind(self, netcdf, lat0, lon0, lat1, lon1, hour):
 
         # Load reanalysis data 
-        level = netcdf['level'][:].data
+        level = netcdf['pressure_level'][:].data
         lats  = netcdf['latitude'][:].data
         lons  = netcdf['longitude'][:].data
         vxs_  = netcdf['u'][:].squeeze().data
@@ -184,7 +184,7 @@ class WindECMWF(WindSim):
         data = data[np.lexsort((data[:, 2], data[:, 1], data[:, 0]))] # Sort by lat, lon, alt
         reshapefactor = int((1 + (max(self.lat0, self.lat1) - min(self.lat0, self.lat1))*4) * \
                             (1 + (max(self.lon0, self.lon1) - min(self.lon0, self.lon1))*4))
-
+        print(f"Calculated reshape factor: {reshapefactor}, Expected: {data.shape[0]}")
         lat     = np.reshape(data[:,0], (reshapefactor, -1)).T[0,:]
         lon     = np.reshape(data[:,1], (reshapefactor, -1)).T[0,:]
         veast   = np.reshape(data[:,3], (reshapefactor, -1)).T
diff --git a/bluesky/plugins/windecmwfUP.py b/bluesky/plugins/windecmwfUP.py
new file mode 100644
index 00000000..34dddb5b
--- /dev/null
+++ b/bluesky/plugins/windecmwfUP.py
@@ -0,0 +1,270 @@
+"""
+plugin with update function in 3h intervals
+ERA5 data was migrated to CDS completely https://cds.climate.copernicus.eu
+
+- you need an CDS / ECMWF account to retrieve data!!!
+- usage: [windecmwfup 20 0 90 -90 yyyy mm dd hh]
+- resolution of data need to be 0.25x0.25 (see reshapefactor)
+
+written by Nils Ahrenhold (TUD/DLR) 22.01.2025 """
+
+from pathlib import Path
+import cdsapi
+import datetime
+import numpy as np
+import bluesky as bs
+import netCDF4 as nc
+from bluesky import stack
+from bluesky.core import timed_function
+from bluesky.traffic.windsim import WindSim
+
+
+datadir = Path('')
+
+
+def init_plugin():
+    global datadir
+    datadir = bs.resource(bs.settings.data_path) / 'NetCDF'
+
+    if not datadir.is_dir():
+        datadir.mkdir()
+
+    global windecmwfup
+    windecmwfup = WindECMWFUP()
+
+    config = {
+        'plugin_name': 'WINDECMWFUP',
+        'plugin_type': 'sim'
+    }
+
+    return config
+
+class WindECMWFUP(WindSim):
+    def __init__(self):
+        super().__init__()
+        self.year  = 0
+        self.month = 0
+        self.day   = 0
+        self.hour  = 0
+        self.lat0  = -90 # South Pole (min latitude)
+        self.lon0  = -180 # Western Hemisphere (min longitude)
+        self.lat1  = 90 # North Pole (max latitude)
+        self.lon1  = 180 # Eastern Hemisphere (max longitude)
+
+        # Switch for periodic loading of new GFS data
+        self.autoload = True
+        
+    def fetch_nc(self, year, month, day):
+        """
+        Retrieve weather data via the CDS API for multiple pressure levels
+        """
+        
+        ymd = "%04d%02d%02d" % (year, month, day)
+        fname = f'p_levels_{ymd}.nc'
+        fpath = datadir / fname
+
+        # **Cache file in memory** instead of reading from disk each time
+        if hasattr(self, "netcdf") and self.netcdf.getncattr("date") == ymd:
+            return self.netcdf  # Use already loaded file
+
+
+        if not fpath.is_file():
+            bs.scr.echo("Downloading file, please wait...")
+    
+            # Set client
+            c = cdsapi.Client()
+            
+            # Retrieve data 
+            c.retrieve(
+                'reanalysis-era5-pressure-levels',
+                {
+                    'product_type': ['reanalysis'],
+                    'variable': [
+                        'u_component_of_wind',
+                        'v_component_of_wind'
+                    ],
+                    'year': year,
+                    'month': month,
+                    'day': day,
+                    'time': [
+                        '00:00', '01:00', '02:00', '03:00',
+                        '04:00', '05:00', '06:00', '07:00',
+                        '08:00', '09:00', '10:00', '11:00',
+                        '12:00', '13:00', '14:00', '15:00',
+                        '16:00', '17:00', '18:00', '19:00',
+                        '20:00', '21:00', '22:00', '23:00'
+                    ],
+                    'pressure_level': [
+                        '100', '125', '150', 
+                        '175', '200', '225',
+                        '250', '300', '350',
+                        '400', '450', '500',
+                        '550', '600', '650', 
+                        '700', '750', '775',
+                        '800'
+                    ],
+                    'data_format': 'netcdf',
+                    "download_format": "unarchived",
+                    "area": [90, -180, -90, 180]             
+                },
+                fpath)
+    
+        bs.scr.echo("Download completed.")
+        netcdf = nc.Dataset(fpath, mode='r')
+    
+        return netcdf
+
+    
+    def extract_wind(self, netcdf, lat0, lon0, lat1, lon1, hour):
+
+        # Load reanalysis data 
+        level = netcdf['pressure_level'][:].data
+        lats  = netcdf['latitude'][:].data
+        lons  = netcdf['longitude'][:].data
+        vxs_  = netcdf['u'][:].squeeze().data
+        vys_  = netcdf['v'][:].squeeze().data
+        
+        # Close data for performance
+        netcdf.close()   
+        
+        # Transform pressure levels to altitude
+        p = level * 100
+        h = (1 - (p / 101325.0)**0.190264) * 44330.76923    # in meters
+        
+        # Set hour to rounded hour
+        #hour = round(hour/3)
+        
+        # Construct 2D array of all data points
+        lats_ = np.tile(np.repeat(lats, len(lons)), len(level))
+        lons_ = np.tile(lons, len(lats)*len(level))
+        alts_ = np.repeat(h, len(lats)*len(lons))       
+        vxs_  = vxs_[hour,:,:,:].flatten() #u_component_of_wind - selects wind data for a specific time step (given by hour)
+        vys_  = vys_[hour,:,:,:].flatten() #v_component_of_wind - selects wind data for a specific time step (given by hour)
+            
+        # Convert longitudes
+        lons_ = (lons_ + 180) % 360.0 - 180.0     # convert range from 0~360 to -180~180
+
+        # Reduce area based on lat lon limits
+        lat0_ = min(lat0, lat1)
+        lat1_ = max(lat0, lat1)
+        lon0_ = min(lon0, lon1)
+        lon1_ = max(lon0, lon1)
+
+        mask = (lats_ >= lat0_) & (lats_ <= lat1_) & (lons_ >= lon0_) & (lons_ <= lon1_)
+
+        data = np.array([lats_[mask], lons_[mask], alts_[mask], vxs_[mask], vys_[mask]])
+
+        return data
+
+
+    @stack.command(name='WINDECMWFUP')
+    def loadwind(self, lat0: 'lat', lon0: 'lon', lat1: 'lat', lon1: 'lon',
+               year: int=None, month: int=None, day: int=None, hour: int=None):
+        ''' WINDECMWFUP: Load a windfield directly from CDS database.
+
+
+            Arguments:
+            - lat0 (south), lon0(east), lat1(north), lon1(west) [deg]:
+            - windecmwfup 20 0 90 -90 yyyy mm dd hh
+
+            Bounding box in which to generate wind field
+            - year, month, day, hour: Date and time of wind data (optional, will use
+              current simulation UTC if not specified).
+        '''
+        self.lat0, self.lon0, self.lat1, self.lon1 =  min(lat0, lat1), \
+                              min(lon0, lon1), max(lat0, lat1), max(lon0, lon1)
+        self.year = year or bs.sim.utc.year
+        self.month = month or bs.sim.utc.month
+        self.day = day or bs.sim.utc.day
+        #self.hour = hour or bs.sim.utc.hour
+        self.hour = hour if hour is not None else bs.sim.utc.hour  # <-- Only override if hour is not provided
+
+        # round hour to 3 hours
+        # self.hour  = round(self.hour/3) * 3
+        
+        if self.hour == 24:
+            ymd0 = "%04d%02d%02d" % (self.year, self.month, self.day)
+            ymd1 = (datetime.datetime.strptime(ymd0, '%Y%m%d') + 
+                    datetime.timedelta(days=1))
+            self.year  = ymd1.year
+            self.month = ymd1.month
+            self.day   = ymd1.day
+            self.hour  = 0
+
+        txt = "Loading wind field for %s-%s-%s-%02d:00..." % (self.year, self.month, self.day, self.hour)
+        bs.scr.echo("%s" % txt)
+
+        netcdf = self.fetch_nc(self.year, self.month, self.day)
+
+        if netcdf is None or self.lat0 == self.lat1 or self.lon0 == self.lon1:
+            return False, "Wind data non-existend in area [%d, %d], [%d, %d]. " \
+                % (self.lat0, self.lat1, self.lon0, self.lon1) \
+                + "time: %04d-%02d-%02d" \
+                % (self.year, self.month, self.day)
+
+        # first clear exisiting wind field
+        self.clear()
+
+        # add new wind field
+        data = self.extract_wind(netcdf, self.lat0, self.lon0, self.lat1, self.lon1, self.hour).T
+        
+        data = data[np.lexsort((data[:, 2], data[:, 1], data[:, 0]))] # Sort by lat, lon, alt        
+        reshapefactor = int((1 + (max(self.lat0, self.lat1) - min(self.lat0, self.lat1))*4) * \
+                            (1 + (max(self.lon0, self.lon1) - min(self.lon0, self.lon1))*4))
+        
+        lat     = np.reshape(data[:,0], (reshapefactor, -1)).T[0,:]
+        lon     = np.reshape(data[:,1], (reshapefactor, -1)).T[0,:]
+        veast   = np.reshape(data[:,3], (reshapefactor, -1)).T
+        vnorth  = np.reshape(data[:,4], (reshapefactor, -1)).T
+        windalt = np.reshape(data[:,2], (reshapefactor, -1)).T[:,0]
+
+        self.addpointvne(lat, lon, vnorth, veast, windalt)        
+
+        return True, "Wind field updated in area [%d, %d], [%d, %d]. " \
+            % (self.lat0, self.lat1, self.lon0, self.lon1) \
+            + "time: %04d-%02d-%02d-%02d:00" \
+            % (self.year, self.month, self.day, self.hour)
+
+    @timed_function(name='WINDECMWFUP', dt=28800) #1h = 3600, 2h = 7200, 3h = 10800,  4h = 14400, 5h = 18000, 6h = 21600, 8h = 28800
+    def update(self):
+        if self.autoload:
+            bs.scr.echo("updating windfield")
+            # Increment the hour by to get the next timestep
+            self.hour += 8
+            
+            # Check if the hour exceeds 24, and adjust the date if needed
+            if self.hour >= 24:
+                self.hour = 0
+                current_date = datetime.date(self.year, self.month, self.day)
+                next_date = current_date + datetime.timedelta(days=1)
+                self.year = next_date.year
+                self.month = next_date.month
+                self.day = next_date.day
+
+            # **Only reload data if date changed**
+            if self.hour == 0:
+                self.netcdf = self.fetch_nc(self.year, self.month, self.day)
+
+            info = f"Current wind data hour: {self.hour:02d}:00"
+            bs.scr.echo(info)
+            # Load the wind data for the next time step for defined coordinates
+            _, txt = self.loadwind(self.lat0, self.lon0, self.lat1, self.lon1,
+                                   self.year, self.month, self.day, self.hour)
+
+            bs.scr.echo("%s" % txt)
+            bs.scr.echo(f"Wind field updated: {self.year}-{self.month}-{self.day} {self.hour}:00")
+            
+            """
+            # **Reuse extracted wind data**
+            wind_data = self.extract_wind(self.netcdf, self.lat0, self.lon0, self.lat1, self.lon1, self.hour)
+
+            # First clear existing wind field
+            self.clear()
+
+            # Reshape and apply data
+            lat, lon, alt, veast, vnorth = wind_data.T
+            self.addpointvne(lat, lon, vnorth, veast, alt)
+            """
+                        
+            
+        
\ No newline at end of file
diff --git a/bluesky/plugins/windecmwfUP12.py b/bluesky/plugins/windecmwfUP12.py
new file mode 100644
index 00000000..fa9e3adc
--- /dev/null
+++ b/bluesky/plugins/windecmwfUP12.py
@@ -0,0 +1,270 @@
+"""
+plugin with update function in 3h intervals
+ERA5 data was migrated to CDS completely https://cds.climate.copernicus.eu
+
+- you need an CDS / ECMWF account to retrieve data!!!
+- usage: [WINDECMWFUP12 20 0 90 -90 yyyy mm dd hh]
+- resolution of data need to be 0.25x0.25 (see reshapefactor)
+
+written by Nils Ahrenhold (TUD/DLR) 22.01.2025 """
+
+from pathlib import Path
+import cdsapi
+import datetime
+import numpy as np
+import bluesky as bs
+import netCDF4 as nc
+from bluesky import stack
+from bluesky.core import timed_function
+from bluesky.traffic.windsim import WindSim
+
+
+datadir = Path('')
+
+
+def init_plugin():
+    global datadir
+    datadir = bs.resource(bs.settings.data_path) / 'NetCDF'
+
+    if not datadir.is_dir():
+        datadir.mkdir()
+
+    global windecmwfup12
+    windecmwfup12 = WindECMWFUP12()
+
+    config = {
+        'plugin_name': 'WINDECMWFUP12',
+        'plugin_type': 'sim'
+    }
+
+    return config
+
+class WindECMWFUP12(WindSim):
+    def __init__(self):
+        super().__init__()
+        self.year  = 0
+        self.month = 0
+        self.day   = 0
+        self.hour  = 0
+        self.lat0  = -90 # South Pole (min latitude)
+        self.lon0  = -180 # Western Hemisphere (min longitude)
+        self.lat1  = 90 # North Pole (max latitude)
+        self.lon1  = 180 # Eastern Hemisphere (max longitude)
+
+        # Switch for periodic loading of new GFS data
+        self.autoload = True
+        
+    def fetch_nc(self, year, month, day):
+        """
+        Retrieve weather data via the CDS API for multiple pressure levels
+        """
+        
+        ymd = "%04d%02d%02d" % (year, month, day)
+        fname = f'p_levels_{ymd}.nc'
+        fpath = datadir / fname
+
+        # **Cache file in memory** instead of reading from disk each time
+        if hasattr(self, "netcdf") and self.netcdf.getncattr("date") == ymd:
+            return self.netcdf  # Use already loaded file
+
+
+        if not fpath.is_file():
+            bs.scr.echo("Downloading file, please wait...")
+    
+            # Set client
+            c = cdsapi.Client()
+            
+            # Retrieve data 
+            c.retrieve(
+                'reanalysis-era5-pressure-levels',
+                {
+                    'product_type': ['reanalysis'],
+                    'variable': [
+                        'u_component_of_wind',
+                        'v_component_of_wind'
+                    ],
+                    'year': year,
+                    'month': month,
+                    'day': day,
+                    'time': [
+                        '00:00', '01:00', '02:00', '03:00',
+                        '04:00', '05:00', '06:00', '07:00',
+                        '08:00', '09:00', '10:00', '11:00',
+                        '12:00', '13:00', '14:00', '15:00',
+                        '16:00', '17:00', '18:00', '19:00',
+                        '20:00', '21:00', '22:00', '23:00'
+                    ],
+                    'pressure_level': [
+                        '100', '125', '150', 
+                        '175', '200', '225',
+                        '250', '300', '350',
+                        '400', '450', '500',
+                        '550', '600', '650', 
+                        '700', '750', '775',
+                        '800'
+                    ],
+                    'data_format': 'netcdf',
+                    "download_format": "unarchived",
+                    "area": [90, -180, -90, 180]             
+                },
+                fpath)
+    
+        bs.scr.echo("Download completed.")
+        netcdf = nc.Dataset(fpath, mode='r')
+    
+        return netcdf
+
+    
+    def extract_wind(self, netcdf, lat0, lon0, lat1, lon1, hour):
+
+        # Load reanalysis data 
+        level = netcdf['pressure_level'][:].data
+        lats  = netcdf['latitude'][:].data
+        lons  = netcdf['longitude'][:].data
+        vxs_  = netcdf['u'][:].squeeze().data
+        vys_  = netcdf['v'][:].squeeze().data
+        
+        # Close data for performance
+        netcdf.close()   
+        
+        # Transform pressure levels to altitude
+        p = level * 100
+        h = (1 - (p / 101325.0)**0.190264) * 44330.76923    # in meters
+        
+        # Set hour to rounded hour
+        #hour = round(hour/3)
+        
+        # Construct 2D array of all data points
+        lats_ = np.tile(np.repeat(lats, len(lons)), len(level))
+        lons_ = np.tile(lons, len(lats)*len(level))
+        alts_ = np.repeat(h, len(lats)*len(lons))       
+        vxs_  = vxs_[hour,:,:,:].flatten() #u_component_of_wind - selects wind data for a specific time step (given by hour)
+        vys_  = vys_[hour,:,:,:].flatten() #v_component_of_wind - selects wind data for a specific time step (given by hour)
+            
+        # Convert longitudes
+        lons_ = (lons_ + 180) % 360.0 - 180.0     # convert range from 0~360 to -180~180
+
+        # Reduce area based on lat lon limits
+        lat0_ = min(lat0, lat1)
+        lat1_ = max(lat0, lat1)
+        lon0_ = min(lon0, lon1)
+        lon1_ = max(lon0, lon1)
+
+        mask = (lats_ >= lat0_) & (lats_ <= lat1_) & (lons_ >= lon0_) & (lons_ <= lon1_)
+
+        data = np.array([lats_[mask], lons_[mask], alts_[mask], vxs_[mask], vys_[mask]])
+
+        return data
+
+
+    @stack.command(name='WINDECMWFUP12')
+    def loadwind(self, lat0: 'lat', lon0: 'lon', lat1: 'lat', lon1: 'lon',
+               year: int=None, month: int=None, day: int=None, hour: int=None):
+        ''' WINDECMWFUP: Load a windfield directly from CDS database.
+
+
+            Arguments:
+            - lat0 (south), lon0(east), lat1(north), lon1(west) [deg]:
+            - windecmwfup 20 0 90 -90 yyyy mm dd hh
+
+            Bounding box in which to generate wind field
+            - year, month, day, hour: Date and time of wind data (optional, will use
+              current simulation UTC if not specified).
+        '''
+        self.lat0, self.lon0, self.lat1, self.lon1 =  min(lat0, lat1), \
+                              min(lon0, lon1), max(lat0, lat1), max(lon0, lon1)
+        self.year = year or bs.sim.utc.year
+        self.month = month or bs.sim.utc.month
+        self.day = day or bs.sim.utc.day
+        #self.hour = hour or bs.sim.utc.hour
+        self.hour = hour if hour is not None else bs.sim.utc.hour  # <-- Only override if hour is not provided
+
+        # round hour to 3 hours
+        # self.hour  = round(self.hour/3) * 3
+        
+        if self.hour == 24:
+            ymd0 = "%04d%02d%02d" % (self.year, self.month, self.day)
+            ymd1 = (datetime.datetime.strptime(ymd0, '%Y%m%d') + 
+                    datetime.timedelta(days=1))
+            self.year  = ymd1.year
+            self.month = ymd1.month
+            self.day   = ymd1.day
+            self.hour  = 0
+
+        txt = "Loading wind field for %s-%s-%s-%02d:00..." % (self.year, self.month, self.day, self.hour)
+        bs.scr.echo("%s" % txt)
+
+        netcdf = self.fetch_nc(self.year, self.month, self.day)
+
+        if netcdf is None or self.lat0 == self.lat1 or self.lon0 == self.lon1:
+            return False, "Wind data non-existend in area [%d, %d], [%d, %d]. " \
+                % (self.lat0, self.lat1, self.lon0, self.lon1) \
+                + "time: %04d-%02d-%02d" \
+                % (self.year, self.month, self.day)
+
+        # first clear exisiting wind field
+        self.clear()
+
+        # add new wind field
+        data = self.extract_wind(netcdf, self.lat0, self.lon0, self.lat1, self.lon1, self.hour).T
+        
+        data = data[np.lexsort((data[:, 2], data[:, 1], data[:, 0]))] # Sort by lat, lon, alt        
+        reshapefactor = int((1 + (max(self.lat0, self.lat1) - min(self.lat0, self.lat1))*4) * \
+                            (1 + (max(self.lon0, self.lon1) - min(self.lon0, self.lon1))*4))
+        
+        lat     = np.reshape(data[:,0], (reshapefactor, -1)).T[0,:]
+        lon     = np.reshape(data[:,1], (reshapefactor, -1)).T[0,:]
+        veast   = np.reshape(data[:,3], (reshapefactor, -1)).T
+        vnorth  = np.reshape(data[:,4], (reshapefactor, -1)).T
+        windalt = np.reshape(data[:,2], (reshapefactor, -1)).T[:,0]
+
+        self.addpointvne(lat, lon, vnorth, veast, windalt)        
+
+        return True, "Wind field updated in area [%d, %d], [%d, %d]. " \
+            % (self.lat0, self.lat1, self.lon0, self.lon1) \
+            + "time: %04d-%02d-%02d-%02d:00" \
+            % (self.year, self.month, self.day, self.hour)
+
+    @timed_function(name='WINDECMWFUP12', dt=43200) #12h = 43200, 2h = 7200, 3h = 10800,  4h = 14400, 5h = 18000, 6h = 21600
+    def update(self):
+        if self.autoload:
+            bs.scr.echo("updating windfield")
+            # Increment the hour by to get the next timestep
+            self.hour += 12
+            
+            # Check if the hour exceeds 24, and adjust the date if needed
+            if self.hour >= 24:
+                self.hour = 0
+                current_date = datetime.date(self.year, self.month, self.day)
+                next_date = current_date + datetime.timedelta(days=1)
+                self.year = next_date.year
+                self.month = next_date.month
+                self.day = next_date.day
+
+            # **Only reload data if date changed**
+            if self.hour == 0:
+                self.netcdf = self.fetch_nc(self.year, self.month, self.day)
+
+            info = f"Current wind data hour: {self.hour:02d}:00"
+            bs.scr.echo(info)
+            # Load the wind data for the next time step for defined coordinates
+            _, txt = self.loadwind(self.lat0, self.lon0, self.lat1, self.lon1,
+                                   self.year, self.month, self.day, self.hour)
+
+            bs.scr.echo("%s" % txt)
+            bs.scr.echo(f"Wind field updated: {self.year}-{self.month}-{self.day} {self.hour}:00")
+            
+            """
+            # **Reuse extracted wind data**
+            wind_data = self.extract_wind(self.netcdf, self.lat0, self.lon0, self.lat1, self.lon1, self.hour)
+
+            # First clear existing wind field
+            self.clear()
+
+            # Reshape and apply data
+            lat, lon, alt, veast, vnorth = wind_data.T
+            self.addpointvne(lat, lon, vnorth, veast, alt)
+            """
+                        
+            
+        
\ No newline at end of file
diff --git a/bluesky/plugins/windgfsUP.py b/bluesky/plugins/windgfsUP.py
new file mode 100644
index 00000000..bc292a05
--- /dev/null
+++ b/bluesky/plugins/windgfsUP.py
@@ -0,0 +1,238 @@
+# Plugin with update function for 6 h intervals
+
+from pathlib import Path
+import sys
+import pygrib
+import datetime
+import requests
+import numpy as np
+import bluesky as bs
+from bluesky import stack
+from bluesky.core import timed_function
+from bluesky.traffic.windsim import WindSim
+
+bs.settings.set_variable_defaults(
+    windgfs_url="https://www.ncei.noaa.gov/data/global-forecast-system/access/historical/analysis/")
+
+# nlayer = 23
+
+datadir = Path('')
+
+def init_plugin():
+    global datadir
+    datadir = bs.resource(bs.settings.data_path) / 'grib'
+
+    if not datadir.is_dir():
+        datadir.mkdir()
+
+    global windgfsup
+    windgfsup = WindGFSUP()
+
+    config = {
+        'plugin_name': 'WINDGFSUP',
+        'plugin_type': 'sim'
+    }
+
+    return config
+
+class WindGFSUP(WindSim):
+    def __init__(self):
+        super().__init__()
+        self.year  = 0
+        self.month = 0
+        self.day   = 0
+        self.hour  = 0
+        self.lat0  = -90
+        self.lon0  = -180
+        self.lat1  = 90
+        self.lon1  = 180
+
+        # Switch for periodic loading of new GFS data
+        self.autoload = True
+
+    def fetch_grb(self, year, month, day, hour, pred=0):
+        ym = "%04d%02d" % (year, month)
+        ymd = "%04d%02d%02d" % (year, month, day)
+        hm = "%02d00" % hour
+        pred = "%03d" % pred
+
+        remote_loc = "/%s/%s/gfsanl_3_%s_%s_%s.grb2" % (ym, ymd, ymd, hm, pred)
+
+        fname = "gfsanl_3_%s_%s_%s.grb2" % (ymd, hm, pred)
+        fpath = datadir / fname
+        if fpath.is_file():
+            info = "WIND: using wind data from directory for %s-%s-%s-%s:00" % (self.year, self.month, self.day, self.hour)
+            print(info)
+
+        remote_url = bs.settings.windgfs_url + remote_loc
+
+        if not fpath.is_file():
+            bs.scr.echo("Downloading file, please wait...")
+            print("Downloading %s" % remote_url)
+
+            response = requests.get(remote_url, stream=True)
+
+            if response.status_code != 200:
+                print("Error. remote data not found")
+                return None
+
+            with open(fpath, "wb") as f:
+                total_length = response.headers.get('content-length')
+
+                if total_length is None:  # no content length header
+                    f.write(response.content)
+                else:
+                    dl = 0
+                    total_length = int(total_length)
+                    for data in response.iter_content(chunk_size=4096):
+                        dl += len(data)
+                        f.write(data)
+                        done = int(50 * dl / total_length)
+                        sys.stdout.write("\r[%s%s]" % ('=' * done, ' ' * (50-done)) )
+                        sys.stdout.flush()
+
+        bs.scr.echo("Download completed.")
+        grb = pygrib.open(fpath)
+
+        return grb
+
+    def extract_wind(self, grb, lat0, lon0, lat1, lon1):
+
+        grb_wind_v = grb.select(shortName="v", typeOfLevel=['isobaricInhPa'])
+        grb_wind_u = grb.select(shortName="u", typeOfLevel=['isobaricInhPa'])
+
+        lats = np.array([])
+        lons = np.array([])
+        alts = np.array([])
+        vxs = np.array([])
+        vys = np.array([])
+
+        for grbu, grbv in zip(grb_wind_u, grb_wind_v):
+            level = grbu.level
+
+            if level < 100:  # lesss than 100 hPa, above about 54 k ft
+                continue
+            else:
+                vxs_ = grbu.values
+                vys_ = grbv.values
+
+                p = level * 100
+                h = (1 - (p / 101325.0)**0.190264) * 44330.76923    # in meters
+
+                lats_ = grbu.latlons()[0].flatten()
+                lons_ = grbu.latlons()[1].flatten()
+                alts_ = round(h) * np.ones(len(lats_))
+
+                lats = np.append(lats, lats_)
+                lons = np.append(lons, lons_)
+                alts = np.append(alts, alts_)
+                vxs = np.append(vxs, vxs_)
+                vys = np.append(vys, vys_)
+
+        lons = (lons + 180) % 360.0 - 180.0     # convert range from 0~360 to -180~180
+
+        lat0_ = min(lat0, lat1)
+        lat1_ = max(lat0, lat1)
+        lon0_ = min(lon0, lon1)
+        lon1_ = max(lon0, lon1)
+
+        mask = (lats >= lat0_) & (lats <= lat1_) & (lons >= lon0_) & (lons <= lon1_)
+
+        data = np.array([lats[mask], lons[mask], alts[mask], vxs[mask], vys[mask]])
+
+        return data
+
+    @stack.command(name='WINDGFSUP')
+    def loadwind(self, lat0: 'lat', lon0: 'lon', lat1: 'lat', lon1: 'lon',
+               year: int=None, month: int=None, day: int=None, hour: int=None):
+        ''' WINDGFSUP: Load a windfield directly from NOAA database and update it each hour.
+
+            Arguments:
+            - lat0, lon0, lat1, lon1 [deg]: Bounding box in which to generate wind field
+            - year, month, day, hour: Date and time of wind data (optional, will use
+              current simulation UTC if not specified).
+        '''
+        self.lat0, self.lon0, self.lat1, self.lon1 =  min(lat0, lat1), \
+                              min(lon0, lon1), max(lat0, lat1), max(lon0, lon1)
+        self.year = year or bs.sim.utc.year
+        self.month = month or bs.sim.utc.month
+        self.day = day or bs.sim.utc.day
+
+        if hour is not None:
+            self.hour = hour  # Use the passed value if provided
+
+        # Round hour to 3-hour steps only if not explicitly set
+        if hour is None:
+            self.hour = round(self.hour / 3) * 3
+            if self.hour in [3, 9, 15, 21]:
+                self.hour = self.hour - 3
+                pred = 3
+        elif self.hour == 24:
+            ymd0 = "%04d%02d%02d" % (self.year, self.month, self.day)
+            print(ymd0)
+            ymd1 = (datetime.datetime.strptime(ymd0, '%Y%m%d') + 
+                    datetime.timedelta(days=1))
+            self.year  = ymd1.year
+            self.month = ymd1.month
+            self.day   = ymd1.day    
+            self.hour  = 0
+            pred = 0
+        else:
+            pred = 0
+
+        txt = "Loading wind field for %s-%s-%s %s:00..." % (self.year, self.month, self.day, self.hour)
+        bs.scr.echo("%s" % txt)
+
+        grb = self.fetch_grb(self.year, self.month, self.day, self.hour, pred)
+
+        if grb is None or self.lat0 == self.lat1 or self.lon0 == self.lon1:
+            return False, "Wind data non-existend in area [%d, %d], [%d, %d]. " \
+                % (self.lat0, self.lat1, self.lon0, self.lon1) \
+                + "time: %04d-%02d-%02d %02d:00" \
+                % (self.year, self.month, self.day, self.hour)
+
+        # first clear exisiting wind field
+        self.clear()
+
+        # add new wind field
+        data = self.extract_wind(grb, self.lat0, self.lon0, self.lat1, self.lon1).T
+
+        data = data[np.lexsort((data[:, 2], data[:, 1], data[:, 0]))] # Sort by lat, lon, alt
+        reshapefactor = int((1 + max(self.lat0, self.lat1) - min(self.lat0, self.lat1)) * \
+                            (1 + max(self.lon0, self.lon1) - min(self.lon0, self.lon1)))
+
+        lat     = np.reshape(data[:,0], (reshapefactor, -1)).T[0,:]
+        lon     = np.reshape(data[:,1], (reshapefactor, -1)).T[0,:]
+        veast   = np.reshape(data[:,3], (reshapefactor, -1)).T
+        vnorth  = np.reshape(data[:,4], (reshapefactor, -1)).T
+        windalt = np.reshape(data[:,2], (reshapefactor, -1)).T[:,0]
+
+        self.addpointvne(lat, lon, vnorth, veast, windalt)        
+
+        return True, "Wind field updated in area [%d, %d], [%d, %d]. " \
+            % (self.lat0, self.lat1, self.lon0, self.lon1) \
+            + "time: %04d-%02d-%02d %02d:00" \
+            % (self.year, self.month, self.day, self.hour)
+
+    @timed_function(name='WINDGFSUP', dt=10800) #each 3 hours = 10800 since gfs provides 6h updates with 3h forecast if needed
+    def update(self):
+        if self.autoload:
+            bs.scr.echo("updating windfield")
+            # Increment the hour by 3 to get the next timestep
+            self.hour += 3
+            info = f"Current wind data hour: {self.hour:02d}:00"
+            bs.scr.echo(info)
+            # Check if the hour exceeds 24, and adjust the date if needed
+            if self.hour >= 24:
+                self.hour = 0
+                current_date = datetime.date(self.year, self.month, self.day)
+                next_date = current_date + datetime.timedelta(days=1)
+                self.year = next_date.year
+                self.month = next_date.month
+                self.day = next_date.day
+
+            # Load the wind data for the next time step for defined coordinates
+            _, txt = self.loadwind(self.lat0, self.lon0, self.lat1, self.lon1,
+                                   self.year, self.month, self.day, self.hour)
+
+            bs.scr.echo("%s" % txt)
\ No newline at end of file
diff --git a/bluesky/resources/navdata/airports.dat b/bluesky/resources/navdata/airports.dat
index 65b3864d..c367b45e 100644
--- a/bluesky/resources/navdata/airports.dat
+++ b/bluesky/resources/navdata/airports.dat
@@ -5551,7 +5551,8 @@ LTFC, SULEYMAN DEMIREL, 37.855, 30.368, Large, 9843, TU,2835
 LTFD, BALIKESIR KORFEZ, 39.555, 27.014, Medium, 6824, TU,50 
 LTFE, MILAS BODRUM, 37.251, 27.664, Large, 9842, TU,21 
 LTFH, CARSAMBA, 41.254, 36.567, Medium, 9843, TU,18 
-LTFJ, SABIHA GOKCEN, 40.899, 29.309, Large, 9843, TU,312 
+LTFJ, SABIHA GOKCEN, 40.899, 29.309, Large, 9843, TU,312
+LTFM, Istanbul Airport, 41.2622, 28.7278, Large, , TU, 325 
 LTGP, Gazipa\xc5\x9fa Airport, 36.299, 32.301, Medium, , TU,86 
 LTXE, Karain Airport, 37.096, 30.648, Small, , TU,1015 
 LUBL, BALTI INTL, 47.838, 27.781, Medium, 7245, MD,758 
@@ -6814,7 +6815,8 @@ OSLK, BASSEL AL ASSAD INTL, 35.401, 35.949, Large, 9175, SY,157
 OSPR, PALMYRA, 34.557, 38.317, Medium, 9449, SY,1322 
 OTBD, DOHA INTL, 25.261, 51.565, Large, 15000, QA,35 
 OTBH, AL UDEID AB, 25.117, 51.315, Medium, 12303, QA,130 
-OTBK, AL KHOR, 25.63, 51.507, Small, 5249, QA,10 
+OTBK, AL KHOR, 25.63, 51.507, Small, 5249, QA,10
+OTHH, Hamad International Airport, 25.2731, 51.6081, Large, , QA, 13 
 OYAA, ADEN INTL, 12.83, 45.029, Medium, 10171, YM,7 
 OYAB, Abbse Airport, 15.3, 43.967, Small, 6500, YM,651 
 OYAT, ATAQ, 14.551, 46.826, Medium, 9482, YM,3735 
diff --git a/bluesky/resources/navdata/nav.dat b/bluesky/resources/navdata/nav.dat
index a0a68c7e..6d614c41 100644
--- a/bluesky/resources/navdata/nav.dat
+++ b/bluesky/resources/navdata/nav.dat
@@ -1,5 +1,5 @@
 
-810 Version - data cycle 2013.10, build 20131334, metadata NavXP810.  Copyright  2013, Robin A. Peel (robin@x-plane.com).   This data is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program ("AptNavGNULicence.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+810 Version - data cycle 2013.10, build 20131334, metadata NavXP810.  Copyright  2013, Robin A. Peel (robin@x-plane.com).   This data is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program ("AptNavGNULicence.txt"); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 
 2  38.08777778 -077.32491667      0   396  50    0.0 APH  A P HILL NDB
 2  57.08382000  009.68009300      0   398  25    0.0 GL   AALBORG NDB
@@ -13107,6 +13107,7 @@
 4  41.24363100  036.58223900     18 11010  18     133.637 ICRM LTFH 13  ILS-cat-I
 4  40.90475000  029.32605300    293 10990  18      64.034 ISAB LTFJ 06  ILS-cat-II
 4  40.89153100  029.29016100    285 11090  18     244.010 ISBH LTFJ 24  ILS-cat-I
+4  41.26220000  028.72784000    285 11090  18     244.010 ISBH LTFM 24  ILS-cat-I
 4  47.85638100  027.76895300    758 10910  18     334.708 IBL  LUBL 33  ILS-cat-I
 4  46.92833600  028.95786900    399 11030  18      88.326 IRG  LUKK 08  ILS-cat-I
 4  46.92725600  028.90441100    399 10990  18     268.285 ILD  LUKK 26  ILS-cat-I
diff --git a/bluesky/traffic/asas/mvp.py b/bluesky/traffic/asas/mvp.py
index 36a71321..efccca1e 100644
--- a/bluesky/traffic/asas/mvp.py
+++ b/bluesky/traffic/asas/mvp.py
@@ -305,7 +305,7 @@ class MVP(ConflictResolution):
         # to make sure that resolution does not graze IPZ
         if rpz_m < dist and dabsH < dist:
             # Compute the resolution velocity vector in horizontal direction.
-            # abs(tcpa) because it bcomes negative during intrusion.
+            # abs(tcpa) because it becomes negative during intrusion.
             erratum = np.cos(np.arcsin(rpz_m / dist)-np.arcsin(dabsH / dist))
             dv1 = ((rpz_m / erratum - dabsH) * dcpa[0]) / (abs(tcpa) * dabsH)
             dv2 = ((rpz_m / erratum - dabsH) * dcpa[1]) / (abs(tcpa) * dabsH)
diff --git a/data/NetCDF/p_levels_20190315.nc b/data/NetCDF/p_levels_20190315.nc
new file mode 100644
index 0000000000000000000000000000000000000000..63511ae1df7300c19b8bb462e9ec85be0991f58f
GIT binary patch
